<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GIC - 跨越边界——固件工程师视角下的芯片与系统</title>


        <!-- Custom HTML head -->

        <meta name="description" content="涵盖硬件接口、芯片设计、固件开发、内核协同、AI基础设施的全栈技术知识库">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">跨越边界——固件工程师视角下的芯片与系统</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="arm-gic"><a class="header" href="#arm-gic">ARM GIC</a></h1>
<p>[toc]</p>
<h2 id="gic-发展"><a class="header" href="#gic-发展">GIC 发展</a></h2>
<p>在早期 ARM 系统（例如 ARM7 和 ARM9）中， 采用单核处理器设计，系统支持的中断源
比较少并且是单核处理器系统，使用简单的寄存器表示每个中断源的使能、关闭以及状态。假
设系统一共有 64 个中断源，每个寄存器一共有 32 位，每位描述一个中断源，那么只需要两个
中断使能寄存器（Interrupt Enable Register， IER）。 同理， 中断状态寄存器（Interrupt Status Register，ISR） 也只需要两个寄存器就够了。</p>
<p>在现在越来越复杂的 SoC 中，中断管理变得越来越困难，原因主要有以下几个方面：</p>
<ul>
<li>中断源变得越来越多，有的系统中断源有几百个，甚至上千个。</li>
<li>中断类型也越来越多，比如普通的外设中断、软件触发的中断、 CPU 内核间的中断，
还有类似于 PCIe 上基于消息传递的中断等。</li>
<li>需要考虑虚拟化的支持。</li>
</ul>
<p>比如，某个服务器芯片，有几十个core，每个core可能有多个中断，有多个PCIe子系统，一个子系统可能有500多个中断。</p>
<p>出于上面几个原因， ARM 公司开发了 GIC， 专门用来管理中断。 目前最新版本是 V4，典型
的 IP 是 GIC-700。 GIC 的发展史如表 13.1 所示。 其中， GIC-V1 指的是协议或者规范的版本， 而GIC-390 指的是具体中断控制器 IP 的型号。 ARM 公司先要制定出规范，然后再设计和实现 IP。</p>
<p><img src="images/GIC/image-20240710145328332.png" alt="image-20240710145328332" /></p>
<p>C2K使用的是GIC V4.1.</p>
<p>传统模式</p>
<p><img src="images/GIC/image-20240710153531028.png" alt="image-20240710153531028" /></p>
<p>MSI模式</p>
<p><img src="images/GIC/image-20240710153547516.png" alt="image-20240710153547516" /></p>
<h3 id="gic-v3"><a class="header" href="#gic-v3">GIC-V3</a></h3>
<p>GIC-V3 主要新增了基于消息传递的中断，类似于 PCIe 中 MSIX 中断。 传统的中断源是需
要一个引脚的，而基于消息传递中断则不需要，只需要在设备内存里写入寄存器就触发中断，
该方案非常合适 PCIe 这类设备，因为 PCIe 上物理引脚有限。另外， GIC-V3 支持 CPU 的内核数量大于 8，适合于服务器处理器。基于 GIC-V3 规范开发的 IP 内核有 GIC-500 和 GIC-600。</p>
<h3 id="gic-v4"><a class="header" href="#gic-v4">GIC-V4</a></h3>
<p>GICv4相较于GICv3的主要新功能和改进：</p>
<ol>
<li><strong>vPE（虚拟处理单元）概念</strong></li>
</ol>
<p>GICv4引入了虚拟处理单元（vPE）的概念，增强了对虚拟化的支持。</p>
<ul>
<li><strong>虚拟中断重定向</strong>：GICv4允许直接将虚拟中断重定向到虚拟处理单元（vPE），这意味着虚拟中断可以直接投递给虚拟机而不需要先由虚拟机监控器（Hypervisor）处理。这减少了中断延迟，提高了虚拟化环境的性能。</li>
</ul>
<ol start="2">
<li><strong>直接中断注入</strong></li>
</ol>
<p>GICv4支持直接中断注入（Direct Injection），使得中断处理更加高效。</p>
<ul>
<li><strong>直接虚拟中断注入</strong>：GICv4允许直接将中断注入到运行中的虚拟机中，而不需要先中断虚拟机监控器。这个功能减少了中断处理的开销，提高了系统的性能。</li>
</ul>
<ol start="3">
<li><strong>增强的虚拟化支持</strong></li>
</ol>
<p>GICv4提供了更好的虚拟化支持，使得中断管理在虚拟化环境中更加高效和灵活。</p>
<ul>
<li><strong>对vPE的直接管理</strong>：GICv4允许虚拟机监控器直接管理和控制虚拟处理单元（vPE），从而更好地分配和控制虚拟中断。</li>
</ul>
<ol start="4">
<li><strong>硬件辅助中断处理</strong></li>
</ol>
<p>GICv4在硬件上增强了对中断处理的支持，减少了软件处理的负担。</p>
<ul>
<li><strong>虚拟中断控制器（vLPI Control）</strong>：GICv4支持虚拟中断的硬件处理，可以更高效地管理和分发虚拟中断。</li>
</ul>
<ol start="5">
<li><strong>扩展的中断优先级</strong></li>
</ol>
<p>GICv4扩展了中断优先级的范围，使得中断的优先级管理更加灵活。</p>
<ul>
<li><strong>更细粒度的优先级控制</strong>：GICv4支持更精细的优先级控制，允许对中断进行更精确的管理。</li>
</ul>
<ol start="6">
<li><strong>中断组的增强</strong></li>
</ol>
<p>GICv4提供了对中断组的更灵活管理。</p>
<ul>
<li><strong>中断组和组安全性</strong>：GICv4增强了对中断组的支持，允许对中断组进行更灵活的配置和管理，提高了系统的安全性和隔离性。</li>
</ul>
<h2 id="中断状态"><a class="header" href="#中断状态">中断状态</a></h2>
<p>每一个中断支持的状态有以下 4 种。
 不活跃（inactive）状态：中断处于无效状态。
 等待（pending）状态：中断处于有效状态，但是等待 CPU 响应该中断。
 活跃（active）状态： CPU 已经响应中断。
 活跃并等待（active and pending） 状态： CPU 正在响应中断， 但是该中断源又发送中断过来。</p>
<p>外设中断支持两种中断触发方式。
 边沿触发（edge-triggered）：当中断源产生一个上升沿或者下降沿时，触发一个中断。
 电平触发（level-triggered）： 当中断信号线产生一个高电平或者低电平时， 触发一个中断。</p>
<h2 id="gic组成"><a class="header" href="#gic组成">GIC组成</a></h2>
<p>对于 GIC 来说， 为每一个硬件中断源分配的中断号就是硬件中断号。 GIC 会为支持的中断
类型分配中断号范围，如表</p>
<p><img src="images/GIC/image-20240710151348491.png" alt="image-20240710151348491" /></p>
<p>具体每个SoC设计各不相同，以下以GIC-V2为例。</p>
<ul>
<li>SGI 通常用于多核之间的通信。SGI通常在Linux内核中被用作处理器之间的
中断（Inter-Processor Interrupt， IPI）， 并会送达系统指定的 CPU 上。</li>
<li>PPI 是每个处理器内核私有的中断。PPI 通常会送达指定的 CPU 上，应用场景有 CPU 本地定时器（local timer）。</li>
<li>SPI 是公用的外设中断。</li>
</ul>
<p>SGI 和 PPI 是每个 CPU 私有的中断，而 SPI 是所有 CPU 内核共享的。</p>
<p>GIC 主要由分发器（distributor）和 CPU 接口组成。分发器具有仲裁和分发的功能，分发
器为每一个中断源维护一个状态机，支持的状态有不活跃状态、等待状态、活跃状态和活跃并
等待。</p>
<p><img src="images/GIC/image-20240710152635739.png" alt="image-20240710152635739" /></p>
<p>GIC-V2 是由两个硬件单元组成的， 一个是分发器， 另一个是 CPU 接口（CPU interface），如图 13.2 所示。分发器主要用来做仲裁和分发， CPU 接口是与 CPU 内核连接的模块。分发器只有一个，是共用的，但是每个 CPU 内核有一个 CPU 接口，它们通过 nIRQ 与 nFIQ 这两个引脚和 CPU 内核连接在一起。</p>
<h2 id="gic-700"><a class="header" href="#gic-700">GIC-700</a></h2>
<p>GIC-700中的组成：</p>
<p><img src="images/GIC/image-20240710152546004.png" alt="image-20240710152546004" /></p>
<p>gic-v3 的组成模块，分别是 Distributor 、Redistributor 、CPU interface 和 ITS （Interrupt Translation Service）。</p>
<p>其中，</p>
<ul>
<li>
<p>Distributor 主要负责 SPI 的管理（priority、affinity、trigger-type），与推送 sgi 、spi 至指定的 Redistributor 。</p>
</li>
<li>
<p>Redistributor 主要负责 PPI 、LPI 的管理（priority、affinity、trigger-type），与推送 PPI 、LPI 送至 CPU interface。</p>
</li>
<li>
<p>CPU interface 负责接收来自 Redistributor 的中断信号，选择合适的中断发送给 CPU，并根据 CPU 的应答动作，协同 Distributor 和 Redistributor 完成中断状态机的状态迁移。</p>
</li>
<li>
<p>ITS 是可选模块，负责接收外设的 msi 消息，并将 msi 消息转换成 LPI 提交给指定的 Redistributor 。</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>英文缩写</th><th>英文全称</th><th>说明</th></tr></thead><tbody>
<tr><td>GIC</td><td>General  Interrupt Controller</td><td>通用中断控制器</td></tr>
<tr><td>SGI</td><td>Software  Generated Interrupt</td><td>核间通信</td></tr>
<tr><td>PPI</td><td>Private  Peripheral Interrupt</td><td>私有中断</td></tr>
<tr><td>SPI</td><td>Shared  Peripheral Interrupt</td><td>共享中断</td></tr>
<tr><td>LPI</td><td>Locality-specific  Peripheral Interrupt</td><td>消息中断</td></tr>
<tr><td>PE</td><td>Process  Element</td><td>处理器单元</td></tr>
<tr><td>ITS</td><td>Interrupt  Translation Service</td><td>中断翻译服务</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>中断</th><th>功能需求</th></tr></thead><tbody>
<tr><td>SGI</td><td>① 可配置中断优先级  ② 触发SGI中断后，该中断会根据不同的security状态和中断group，发送到对应的PE（所有连接的PE / 一组PE）</td></tr>
<tr><td>PPI</td><td>①   可配置中断优先级  ②   触发PPI中断，会被路由到特定的处理器上</td></tr>
<tr><td>SPI</td><td>①   可配置中断优先级  ②   可配置中断的触发方式  ③   根据路由配置发送到对应的PE（某个PE / 一组PE）</td></tr>
<tr><td>LPI</td><td>①   确认LPI实现方式（forwarding方式/ITS方式），并实现相关配置  ②   可配置中断优先级</td></tr>
</tbody></table>
</div>
<p>以下基于linux kernel 5.10。</p>
<div class="table-wrapper"><table><thead><tr><th>中断类型</th><th>中断号</th><th>说明</th></tr></thead><tbody>
<tr><td>SGI</td><td>0 - 15</td><td>每个PE都会备份</td></tr>
<tr><td>PPI</td><td>16 – 31</td><td>每个PE都会备份</td></tr>
<tr><td>SPI</td><td>32 - 1019</td><td></td></tr>
<tr><td>特殊中断号</td><td>1020 - 1023</td><td></td></tr>
<tr><td>保留中断号</td><td>1024 - 1055</td><td></td></tr>
<tr><td>扩展PPI</td><td>1056 -1119</td><td>GICv3.1版本后才支持</td></tr>
<tr><td>保留中断号</td><td>1120 - 4095</td><td></td></tr>
<tr><td>扩展SPI</td><td>4096 - 5119</td><td>GICv3.1版本后才支持</td></tr>
<tr><td>保留中断号</td><td>5120 - 8191</td><td></td></tr>
<tr><td>LPI</td><td>8192 -</td><td>最大支持的中断号由实现确定</td></tr>
</tbody></table>
</div>
<p>可以看到 LPI 的中断号是从 8192 开始的，具体实现多少个 LPI 中断由实现决定。设计人员会在 GICD_TYPER 寄存器 IDbits field 中告知软件具体实现了多少个 LPI。</p>
<p><img src="images/GIC/image-20240710153719002.png" alt="image-20240710153719002" /></p>
<p><img src="images/GIC/image-20240710153330434.png" alt="image-20240710153330434" /></p>
<p>注意区别：</p>
<p>GCI，即GIC Cluster Interface，包含了一个cluster的所有Redistributor；在c2000中，一个EXG对应一个cluster，包含一个core，8个thread；所以一个GCI包含了总共8个Redistributor</p>
<p>c2k框架中的ICI模块为自研模块，对应ARM的CPU interface模块</p>
<h3 id="sgi-中断"><a class="header" href="#sgi-中断">SGI 中断</a></h3>
<p>核间通信：大core A发起请求，到CPU interface，到GICD路由，再发送到目标threadde GICR中，在通过interface给到对应的thread。</p>
<h3 id="ppi-中断"><a class="header" href="#ppi-中断">PPI 中断</a></h3>
<p>私有中断：PPI中断源拉高，进入GICR，通过interface进入指定的thread。</p>
<p>比如EXG自己的timer。</p>
<h3 id="spi-中断"><a class="header" href="#spi-中断">SPI 中断</a></h3>
<p>外设中断：SPI 拉高，GICD根据路由信息，发送到对应的GICR，GICR通过interface到对应的thread。</p>
<p>比如PCIe子系统中的中断。</p>
<h3 id="lpi-中断"><a class="header" href="#lpi-中断">LPI 中断</a></h3>
<p>消息中断：MSI 进来，ITS翻译，找到对应的GICR，GICR通过interface到对应的thread。</p>
<p><img src="images/GIC/image-20240710160158086.png" alt="image-20240710160158086" /></p>
<p>整体处理流程如下；</p>
<ol>
<li>
<p>外设写内存产生中断给ITS，外设写的内容包含device id和event id，device id用于标识设备，event id用于区分同一个设备不同的中断。</p>
</li>
<li>
<p>ITS在内存中有以下三张表，通过这三张表可以知道将中断路由到哪个GICR即哪个CPU：</p>
</li>
</ol>
<p>​       a)  Device table用于保存每个device对应的ITT中断转换表；</p>
<p>​       b)  ITT表用于保存设置event id与collection id的对应关系；</p>
<p>​       c)  Collection table用于保存collection id与GICR的对应关系。</p>
<ol start="3">
<li>ITS驱动或软件通过三种方式与ITS进行通信：通过直接访问ITS寄存器、通过访问或修改三张表、通过CMDQ队列。</li>
</ol>
<p>问题来了，为什么c2k设计MSI是its-&gt;gicd-&gt;gicr ？按照arm的理解是，its通过一系列查表之后得到redistributor（GICR）之后不需要在经过distributor(GICD)了？</p>
<p>咨询前端设计的同事得知，GICD是中心连接其他模块，其他模块没有互联的通路。因此ITS每一次查表都要经过GICD，GICD负责去读ddr查表，然后给到GICR。c2k设计图中反应的是硬件通路，而arm的拓扑关系并没有反映出这一点</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../02__架构篇__核心计算架构深度解析/02_中断控制器/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../02__架构篇__核心计算架构深度解析/02_中断控制器/RISCV_AIA.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../02__架构篇__核心计算架构深度解析/02_中断控制器/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../02__架构篇__核心计算架构深度解析/02_中断控制器/RISCV_AIA.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
