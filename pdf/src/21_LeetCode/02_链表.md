## 链表

[toc]

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) { .unnumbered .unlisted }

找到相交的点，返回。

使用双指针，同时向前走，遇到末尾的空指针，从另一个接着遍历，这样两个指针相等的时候，就是两个链表相交的时候。

例如，一个长，一个段，相交，短的先到终点，然后从长的那边继续遍历，而长的还没到终点，到了以后也开始从短的开始遍历，最终相交时候两个走的路程是一样的。

* 注意判断空指针；

````c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
        if (headA == NULL || headB == NULL) {
            return NULL;
        }
        ListNode *pa = headA;
        ListNode *pb = headB;
        while (pa != pb) {
            pa = (pa == NULL ? headB : pa->next);
            pb = (pb == NULL ? headA : pb->next);
        }
        return pa;
    }
};
````

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/) { .unnumbered .unlisted }

一共需要三个指针，一个头，一个尾（也就是空指针），一个临时指针（临时的头）

断开，反指；

两个指针向前移动；

暂存后继节点；

修改引用指向；

暂存当前节点；

访问下一节点；

````c++
ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr;
        ListNode *curr = head;

        while (curr ！= NULL) {
            /* 就像一首诗，顶真，从temp开始，下一个左值是上一个右值 */
            ListNode * temp = curr->next;
            curr->next = pre;
            pre = curr;
            curr = temp;
        }

        return pre;
````

### [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/) { .unnumbered .unlisted }

反转指定区间的链表

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/) { .unnumbered .unlisted }

放进数组里，前后进行比较；数组可以按照index访问。

````c++
vector<int> nums;

        ListNode* p = head;

        while (p != nullptr) {
            nums.push_back(p->val);
            p = p->next;
        }

        for (int i = 0, j = (int)nums.size() - 1; i < nums.size()/2; i ++, j--) {
            if (nums[i] != nums[j]) {
                return false;
            }
        }
        return true;
````

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/) { .unnumbered .unlisted }

快慢指针

相同跳出循环，不相同继续绕圈圈，如果遇到空的，就说明到头了，返回false.

````c++
       if (head == NULL || head->next == NULL) {
            return false;
        }

        ListNode * fast = head->next;
        ListNode * slow = head;

        while(fast != slow) {
            if (fast == NULL || fast->next == NULL) {
                return false;
            }

            fast = fast->next->next;
            slow = slow->next;
        }
        return true;
````

哈希表

直接往表里塞，如果碰到了一样的，说明就有环了，就找到了。

````c
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode*> table;
        while(head) {
            if (table.find(head) != table.end()) {
                return true;
            }
            table.insert(head);
            head = head->next;
        }
        return false;
        
    }
};
````

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) { .unnumbered .unlisted }

要返回节点的位置：

先一起出发，快慢指针到相交的位置，再来一个指针从头开始，慢指针继续走，他们相交的位置，就是入口点。

他妈的，这里关键是找到数学规律，同时不能按照之前的环形链表去写。

数据规律是：

直线长a，环长b

f=2s

f=s+nb；f比s多走了n圈

由上可得，

s=nb

慢指针再继续走，第三个指针从头走，相遇就找到了。

这他妈的对实际工作几个Jb帮助，纯纯玩呢。

面试考这个，考的是我有没有背下来？还是考我数学推到，垃圾。

````c++

class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (head == NULL || head->next == NULL) {
            return NULL;
        }
        ListNode* fast = head;
        ListNode* slow = head;

        while(true) {
            if (fast == NULL || fast->next == NULL) {
                return NULL;
            }
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) {
                break;
            }
        }

        if (fast == slow) {
            ListNode* ptr = head;
            while (ptr != slow) {
                slow = slow->next;
                ptr = ptr->next;
            }
            return ptr;
        }
        return NULL;
    }
};
````

或者哈希表

直接往表里塞，如果碰到了一样的，说明就有环了，就找到了。

````c
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set<ListNode*> table;
        while(head){
            if (table.find(head) != table.end()) {
                return head;
            }
            table.insert(head);
            head = head->next;
        }
        return NULL;
        
    }
};
````

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) { .unnumbered .unlisted }

````c++

    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (list1 == nullptr) {
            return list2;
        } else if (list2 == nullptr) {
            return list1;
        } else if (list1->val < list2->val) {
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        } else {
            list2->next = mergeTwoLists(list1, list2->next);
            return list2;
        }
    }
````

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) { .unnumbered .unlisted }

递归：

1. 返回值
1. 做什么
1. 终止条件

````c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        // 两两反转，新的头就是第二个节点
        ListNode* newHead = head->next;
        // 递归调用，把第三个节点，也就是newhead的下一个作为参数
        head->next = swapPairs(newHead->next);
        // 新的头，也就是是第二个节点，反向指向第一个节点
        newHead->next = head;
        // 第二个节点作为新的头，返回
        return newHead;
    }
};

````

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/) { .unnumbered .unlisted }

首先判断链表是否有*K*个数，不足则直接返回head。

否则对前*K*个数进行反转，然后进行递归处理。

````c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode *p = head;
        // 首先判断链表是否有*K*个数，不足则直接返回head。
        // 同时记录下第K个节点，方便后面反转
        for(int i = 0; i < k; i++) {
            if(!p) return head;
            p = p->next;
        }

        // *K*个数进行反转
        ListNode *q = head;
        ListNode *pre = nullptr;
        while(q != p) {
            ListNode *tmp = q->next;
            q->next = pre;
            pre = q;
            q = tmp;
        }

        // 递归
        head->next = reverseKGroup(p, k);
        return pre;
    }
};
````

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/) { .unnumbered .unlisted }

将数字逆序存储在链表中

````
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
````

从头开始相加，有进位记录下来，下一个数用。

````c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = nullptr, *tail = nullptr;
        int carry = 0;
        while (l1 || l2) { //遍历链表
            // 任何一个节点中有值的话，就提取出来，没有的话就取0
            int n1 = l1 ? l1->val: 0;
            int n2 = l2 ? l2->val: 0;
            // 两值相加，同时考虑是否有进位
            int sum = n1 + n2 + carry;
            // 如果head为空，说明是第一个节点
            // 对10取余，是因为大于10会被进位，只需要保留余数即可
            if (!head) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail->next = new ListNode(sum % 10);
                tail = tail->next;
            }
            // 记录进位信息
            carry = sum / 10;
            // 节点不空的话，继续向下一个走
            if (l1) {
                l1 = l1->next;
            }
            if (l2) {
                l2 = l2->next;
            }
        }
        // 如果存在进位，在最前面加一个节点
        if (carry > 0) {
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
````

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) { .unnumbered .unlisted }

有可能把头结点给删掉，所以要用一个dummy head

````c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if (head == nullptr || head->next == nullptr) {
            return nullptr;
        }
        ListNode* dummy = new ListNode(0, head);
        ListNode* p1 = head;
        ListNode* p2 = dummy;

        for (int i = 0; i < n; i++) {
            p1 = p1->next;
        }

        while(p1){
            p1 = p1->next;
            p2 = p2->next;
        }

        p2->next = p2->next->next;

        ListNode* ans = dummy->next;
        delete dummy;

        return ans;

    }
};
````

### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/) { .unnumbered .unlisted }

最近最少使用

### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/) { .unnumbered .unlisted }

两次循环，先放哈希表中，再从头遍历确定指针。

先把两个链表放到hash表中；新表只存value，指针先不管；

从头开始遍历，把复制的新表中两个指针挨个确定好；

用哈希表真是巧妙啊！类似DNA双螺旋结构。

````c++
class Solution {
public:
	unordered_map<Node*,Node*>hmap;
    Node* copyRandomList(Node* head) {
        Node *p=head;
        // 把每个节点放到哈希表中，类似复制DNA碱基对
        // 先只复制value，指针后面再更新
        while(p){
			hmap.insert({p,new Node(p->val)});
            p=p->next;
		}
        // 更新两个指针的指向
		p=head;
		while(p){
            // 新节点的next指针
			hmap[p]->next=hmap[p->next];
            // 新节点的random指针
			hmap[p]->random=hmap[p->random];
            p=p->next;
		}
		return hmap[head];
    }
};
````

### [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list) { .unnumbered .unlisted }

````c++
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        // 检查链表是否为空
        if (head == nullptr) {
            return head;
        }
        
        // 创建虚拟头节点来简化插入操作
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head; // 将虚拟头节点连接到原始链表上
        
        ListNode* lastSorted = head; // 指向已排序部分的最后一个节点
        ListNode* curr = head->next; // 指向待插入的节点
        
        // 遍历未排序部分的链表
        while (curr != nullptr) {
            // 如果当前节点的值大于等于已排序部分的最后一个节点的值，将lastSorted向后移动
            if (lastSorted->val <= curr->val) {
                lastSorted = lastSorted->next;
            } else {
                // 在已排序部分中找到合适的插入位置
                ListNode* prev = dummyHead;
                while (prev->next->val <= curr->val) {
                    prev = prev->next;
                }
                
                // 调整指针以插入当前节点
                lastSorted->next = curr->next;
                curr->next = prev->next;
                prev->next = curr;
            }
            
            // 移动到下一个待插入节点
            curr = lastSorted->next;
        }
        
        // 返回排序后的链表（不包括虚拟头节点）
        return dummyHead->next;
    }
};

````

PCIe枚举中用到过这个，收集到的内存块信息存储在链表中，分配内存之前，需要从大到小排序。但那个是按照插入排序，每次插入新的节点，直接找到合适的位置即可。

### [148. 排序链表](https://leetcode.cn/problems/sort-list/) { .unnumbered .unlisted }

````
输入：head = [4,2,1,3]
输出：[1,2,3,4]
````

### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) { .unnumbered .unlisted }