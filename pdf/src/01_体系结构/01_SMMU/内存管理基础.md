### 内存管理基础

[toc]

#### 为什么需要内存管理 { .unnumbered .unlisted }

早期是单道编程的内存管理。   后出现多道编程的内存管理。   多道编程的内存管理有两种方式，固定分区和动态分区两种技术 。

![image-20240711133545527](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711133545527.png)

这种动态分区方法在系统刚启动时效果很好，但是随着时间的推移会出现很多内存空洞，内存的利用率随之下降， 这些内存空洞便是我们常说的内存碎片。 为了解决内存碎片化的问题，操作系统需要动态地移动进程，使得进程占用的空间是连续的，并且所有的空闲空间也是连续的。整个进程的迁移是一个非常耗时的过程。

主要问题：

* 进程地址空间保护问题。A进程踩B进程的内存。
* 内存使用效率低。要换入换出。
* 程序运行地址重定位问题 。需要重定位技术。

解决方案：

地址抽象，每个进程看起来，自己独占所有地址空间。

![image-20240711134934686](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711134934686.png)

这种方案解决了上面三个问题，还剩一个内存碎片。

#### 段页式 { .unnumbered .unlisted }

##### 分段机制 { .unnumbered .unlisted }

**分段机制**，其基本思想是把程序所需的内存空间的虚拟地址映射到某个物理地址空间。

分段机制对虚拟内存到物理内存的映射依然以进程为单位。当物理内存不足时，换出到磁盘的依然是整个进程，因此会有大量的磁盘访问，进而影响系统性能。  常用的留着，不常用的换出到磁盘，会是更好的方案，于是就出现了**分页机制**。

##### 分页机制 { .unnumbered .unlisted }

![image-20240711140707047](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711140707047.png)

4G内存，4K一页，需要2^20 个页表项，每个占用4B，一共需要4M来存这张表。

多进程，每个进程都有一个4M的table，这无法接受，进程多了以后，内存全用来存table了，不用干活了。因此，出现了多级页表。

##### 多级页表 { .unnumbered .unlisted }

把页表分成一级页表和二级页表，页表基地址寄存器指向一级页表的基地址，一级页表的页表项里存放了一个指针，指向二级页表的基地址。当处理器执行程序时，只需要把一级页表加载到内存中，并不需要把所有的二级页表都加载到内存中，而是根据物理内存的分配和映射情况逐步创建和分配二级页表。 这样做有两个原因： 一是程序不会马上使用完所有的物理内存； 二是对于 32 位系统来说， 通常系统配置的物理内存小于 4 GB， 比如仅有 512 MB 内存等。

![image-20240711141407243](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711141407243.png)

图 14.5 展示了二级页表查询过程， VA[31:20]被用作一级页表的索引，一共有 12 位，最多可以索引 4096 个页表项； VA[19:12]被用作二级页表的索引，一共有 8 位，最多可以索引 256 个页表项。当操作系统复制一个新的进程时， **首先会创建一级页表， 分配 16 KB 页面**。 在本场景中， 一级页表有 4096 个页表项， 每个页表项占 4 字节， 因此一级页表一共有 16 KB。 当操作 系统准备让进程运行时，会设置一级页表在物理内存中的起始地址到页表基地址寄存器中。进 程在执行过程中需要访问物理内存，因为一级页表的页表项是空的，这会触发缺页异常。在**缺页异常里分配一个二级页表**，并且把二级页表的起始地址填充到一级页表的相应页表项中。接着，**分配一个物理页面**， 然后把这个物理页面的 PFN 填充到二级页表的对应页表项中， 从而完成页表的填充。随着进程的执行，需要访问越来越多的物理内存，于是操作系统逐步地把页表填充并建立起来。

这样，一级页表变小了，一级页表中很多entry也没有实际的二级页表对应，整体会小很多。比如，可能只需要一个一级页表，5个二级页表，就能完成进程所需的所有内存映射。累计使用只有几KB。

确认使用几层页表的架构。这取决于内核版本、处理器架构。

ARM64 处理器来说， 通常会使用 3 级或者 4 级页表

X86架构，最多支持5级页表。

#### ARM64 内管管理 { .unnumbered .unlisted }

ARM64 处理器内核的 MMU 包括 TLB 和页表遍历单元（ Table Walk Unit， TWU） 两个部件。

![image-20240711143546582](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711143546582.png)

在 SMP（ Symmetric Multi-Processor， 对称多处理器） 系统中， 每个处理器内核内置了 MMU和 TLB 硬件单元。

![image-20240711144032889](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711144032889.png)

##### 页表 { .unnumbered .unlisted }

AArch64 执行状态的 MMU 支持单一阶段的页表转换，也支持虚拟化扩展中两阶段的页表
转换。

单一阶段的页表转换指把虚拟地址（ VA）翻译成物理地址（ PA）。

两阶段的页表转换包括两个阶段。 在阶段 1， 把虚拟地址翻译成中间物理地址（ Intermediate
Physical Address， IPA）；在阶段 2，把 IPA 翻译成最终 PA。

ARMv8 体系结构还支持 4 KB、 16 KB 或 64 KB 这 3 种页面粒度。

在 AArch64 体系结构中，因为地址总线位宽最多支持 48 位，所以 VA 被划分为两个空间， 每个空间最多支持 256 TB。

* 低位的虚拟地址空间位于 0x0000000000000000 到 0x0000FFFFFFFFFFFF。 如果虚拟地
  
  址的最高位等于 0， 就使用这个虚拟地址空间， 并且使用 **TTBR0_ELx** 来存放页表的基
  地址。

* 高位的虚拟地址空间位于 0xFFFF000000000000 到 0xFFFFFFFFFFFFFFFF。如果虚拟
  地址的最高位等于 1， 就使用这个虚拟地址空间， 并且使用 **TTBR1_ELx** 来存放页表的
  基地址。

![image-20240711145449359](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711145449359.png)

48位地址宽度，4K页表查询过程

![image-20240711145404168](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711145404168.png)

##### 两套页表 { .unnumbered .unlisted }

与 x86_64 体系结构的一套页表设计不同， AArch64 执行状态的体系结构采用分离的两套页 表设计。如图 14.16 所示，整个虚拟地址空间分成 3 部分，下面是用户空间，中间是非规范区 域，上面是内核空间。当 CPU 要访问用户空间的地址时， MMU 会自动选择 TTBR0 指向的页 表。当 CPU 要访问内核空间的时候， MMU 会自动选择 TTBR1 这个寄存器指向的页表，这是 硬件自动做的。

![image-20240711145908203](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711145908203.png)

##### 页表项描述符 { .unnumbered .unlisted }

###### L0-L2 Entry { .unnumbered .unlisted }

AArch64 状态的体系结构中 L0～L3 页表项描述符的格式不完全一样。 其中， L0～L2 页表项描述符的内容比较类似，如图 14.17 所示。

![image-20240711150047513](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711150047513.png)

###### L3 Entry { .unnumbered .unlisted }

![image-20240711150252333](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711150252333.png)

#### 寄存器 { .unnumbered .unlisted }

与地址转换相关的控制寄存器主要有如下几个：
 转换控制寄存器（ Translation Control Register， TCR）；
 系统控制寄存器（ System Control Register， SCTLR）；
 转换页表基地址寄存器（ Translation Table Base Register， TTBR）。

#### 恒等映射 { .unnumbered .unlisted }

恒等映射指的是把虚拟地址映射到同等数值的物理地址上， 即虚拟地址（ VA） = 物理地址（ PA）。

![image-20240711150627716](book/pdf/src/01_体系结构/01_SMMU/images/内存管理基础/image-20240711150627716.png)