### Resource Degration

[toc]

在进行资源分配时，根据BAR 的类型创建了5种类型的 resource pool

![image-20230907171728542](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907171728542.png)

五种资源树

````c
    InitializeResourcePool (&IoPool, PciBarTypeIo16);
    InitializeResourcePool (&Mem32Pool, PciBarTypeMem32);
    InitializeResourcePool (&PMem32Pool, PciBarTypePMem32);
    InitializeResourcePool (&Mem64Pool, PciBarTypeMem64);
    InitializeResourcePool (&PMem64Pool, PciBarTypePMem64);
````

在给每个RC 预留空间的时候，只区分了两类地址，没有区分是否prefetchable.

当一些特殊条件不满足时，不同类型的资源会进行相互的转换。

![image-20230907112441286](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907112441286.png)

所有BAR 类型共有11种，可预取的与不可预取的内存空间的对比（Prefetchable vs. Non-Prefetchable Memory Space）可预取空间有两个意义十分明确的属性：

 > 
 > * 读操作不存在副作用。（Reads do not have side effects）
 > 
 > * 允许写合并（Write merging is allowed）

 > 
 > PCIe Technology 3.0  Chapter 4.1.2.2

#### 1. DegradeResource() 函数的降级规则 { .unnumbered .unlisted }

##### 1.1 Degrade Resource For OptionRom { .unnumbered .unlisted }

 > 
 > If any child device has both option ROM and 64-bit BAR, degrade its PMEM64/MEM64
 > 
 > requests in case that if a legacy option ROM image can not access 64-bit resources.

通过一个PCD控制`PcdPciDegradeResourceForOptionRom`

* X64 ---- TRUE
* X32 ARM AARCH64 ---- FALSE

其实这个功能，我觉得已经不用打开了，因为目前使用在root bridge中，借用bar0来进行映射mem32，没有借用自己的bar0，所以不用关心自己的bar是不是64bit。

##### 1.2 Degrade Resource For Others { .unnumbered .unlisted }

````c
  //
  // Degrade resource if necessary
  //
  DegradeResource (Bridge, Mem32Node, PMem32Node, Mem64Node, PMem64Node);
````

使用函数`BridgeSupportResourceDecode()`判断bridge 支持的属性

使用函数`MergeResourceTree()`合并两个resoure tree

![image-20230907153348997](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907153348997.png)

为什么不能同时满足PMem64 和 PMem32？因为bridge的配置空间，不能同时支持。

同时也可以看出，NP-Mem64 不被支持，只能支持32位，因为没有高32位的的寄存器。

![image-20230907100002700](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907100002700.png)

![image-20230906184552816](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230906184552816.png)

#### 2. 具体实现参考 { .unnumbered .unlisted }

##### 2.1 Ampere PCI log： { .unnumbered .unlisted }

![image-20230907103257590](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907103257590.png)

![image-20230907111105623](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907111105623.png)

![](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907110629019.png)

 > 
 > bit0 - 0 表示memory的空间
 > 
 > bit 2:1 表示memory的类型 00 32bit memory类型， 10- 64 bit memory类型B
 > 
 > bit3 - 0 表示Non-prefetchable

**NP-Mem64**

##### 2.2 Degrade Resource 具体实现 { .unnumbered .unlisted }

函数`BridgeSupportResourceDecode()`主要通过检查 PCI_IO_DEVICE.Decodes

![image-20230906184420587](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230906184420587.png)

![image-20230907100002700](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907100002700.png)

判断bridge 支持的属性

````c
#define EFI_BRIDGE_IO32_DECODE_SUPPORTED      0x0001
#define EFI_BRIDGE_PMEM32_DECODE_SUPPORTED    0x0002
#define EFI_BRIDGE_PMEM64_DECODE_SUPPORTED    0x0004
#define EFI_BRIDGE_IO16_DECODE_SUPPORTED      0x0008
#define EFI_BRIDGE_PMEM_MEM_COMBINE_SUPPORTED 0x0010
#define EFI_BRIDGE_MEM64_DECODE_SUPPORTED     0x0020
#define EFI_BRIDGE_MEM32_DECODE_SUPPORTED     0x0040
````

````c
struct _PCI_IO_DEVICE { 
   ···
  //
  // The resource decode the bridge supports
  //
  UINT32                                    Decodes;
  ···
}
````

PCI_IO_DEVICE.Decodes 来源为DetermineRootBridgeAttributes()，这个函数则是通过protocol来获得

````c
PciResAlloc->GetAllocAttributes (
                          PciResAlloc,
                          RootBridgeHandle,
                          &Attributes
                          );
````

* 对于root bridge，其信息流如图所示，根源在映射RC 到 root bridge 时候

* 对于下游的其他bridge，其来源于访问bridge的配置空间
  
  * IO capability -- ACPI spec 7.5.1.3.6
  ![image-20230906181159100](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230906181159100.png)
  
  * Mem capability -- PCIe spec 7.5.1.3.9
    
    The bottom 4 bits of both the Prefetchable Memory Base（0x24） and Prefetchable Memory Limit registers are read-only, contain the same value, and encode whether or not the bridge supports 64-bit addresses
    
    * 0 - the bridge supports only 32 bit addresses.
    * 1 - the bridge supports 64-bit addresses.
  上游的bridge的属性信息：
  
  ![image-20230907145320882](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907145320882.png)
  
  Prefetchable Memory Base  0x002**1**
  
  Prefetchable Memory Limit  0x003**1**
  
  再读一下0x28 寄存器，判断高32位是否有数据，如果有，将PMEM32 和 PMEM64 flag 都置起来；如果不存在，只将PMEM32 置起来。如果同时支持，要将PMEM32 降级 MEM32。因此只要支持PMEM64，PMEM32 偶会被降级 MEM32。
  
  根据PCIe Spec 实现的配置空间和EDK2 的代码实现，除了抽象的Root Bridge 以外，所有bridge 都不会被置MEM64 Flag。因此，所有的bridge都不支持 NP-MEM64， 根据规则，所有的NP-MEM64 tree 都会被merge 到 NP-MEM32 tree 中去。
  
  至此，五种资源树只剩下三种，现在就可以和RC 预留的空间进行对应了。

````c
InitializeResourcePool (&IoPool, PciBarTypeIo16);
InitializeResourcePool (&Mem32Pool, PciBarTypeMem32);
// InitializeResourcePool (&PMem32Pool, PciBarTypePMem32);
// InitializeResourcePool (&Mem64Pool, PciBarTypeMem64);
InitializeResourcePool (&PMem64Pool, PciBarTypePMem64);
````

##### 2.3 RC预留空间类型 { .unnumbered .unlisted }

RC 到 Root Bridge 映射时候直接简化处理：

 > 
 > Mem、PMem =**Mmio32Base**
 > 
 > Io.Base = Mem Limit 向下偏移 IO_SIZE
 > 
 > PMemAbove4G = **MmioBase**
 > 
 > MemAbove4G 没有赋值，使用模版默认值
 > 
 > ````c
 > {  // PMem
 >  MAX_UINT64,
 >  0,
 >  0
 > }
 > ````

![image-20230907132349864](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907132349864.png)

![image-20230907133927772](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907133927772.png)

````c
  if (RootComplex->Mmio32Base != 0) {
      RootBridge->Mem.Base = RootComplex->Mmio32Base;
      RootBridge->Mem.Limit = RootComplex->Mmio32Base + RootComplex->Mmio32Size - 1;
      RootBridge->PMem.Base = RootBridge->Mem.Base;
      RootBridge->PMem.Limit = RootBridge->Mem.Limit;
      RootBridge->Io.Base = RootComplex->Mmio32Base + RootComplex->Mmio32Size - AC01_PCIE_IO_SIZE;
      RootBridge->Io.Limit = RootBridge->Mem.Limit;
    }

    if (RootComplex->MmioBase != 0) {
      RootBridge->PMemAbove4G.Base = RootComplex->MmioBase;
      RootBridge->PMemAbove4G.Limit = RootComplex->MmioBase + RootComplex->MmioSize - 1;
    }
````

````c
if ((Attributes & EFI_PCI_HOST_BRIDGE_COMBINE_MEM_PMEM) != 0) {
    RootBridgeDev->Decodes |= EFI_BRIDGE_PMEM_MEM_COMBINE_SUPPORTED;
  }

  if ((Attributes & EFI_PCI_HOST_BRIDGE_MEM64_DECODE) != 0) {
    RootBridgeDev->Decodes |= EFI_BRIDGE_MEM64_DECODE_SUPPORTED;
    RootBridgeDev->Decodes |= EFI_BRIDGE_PMEM64_DECODE_SUPPORTED;
  }

  RootBridgeDev->Decodes |= EFI_BRIDGE_MEM32_DECODE_SUPPORTED;
  RootBridgeDev->Decodes |= EFI_BRIDGE_PMEM32_DECODE_SUPPORTED;
  RootBridgeDev->Decodes |= EFI_BRIDGE_IO16_DECODE_SUPPORTED;
````

疑问？

NP-MEM64 降级到NP-MEM32，如果bar 需要空间太大，NP-MEM32区间不够分怎么办？

根据这个[测试](https://zhuanlan.zhihu.com/p/539823251)，Linux kernel 5.18.0 环境下，会失败，EDK2 待测试。

根据 PCIe Spec 规定，不应该有NP-MEM64 这样的设备

![image-20230907180903853](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230907180903853.png)

**PCIe 3.0&4.0 Spec**

![image-20230915092058697](book/pdf/src/12_PCIe/02_PCIe枚举与资源分配/images/枚举过程中的资源降级/image-20230915092058697.png)