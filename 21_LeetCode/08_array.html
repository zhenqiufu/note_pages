<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数组 - NoteBook</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">NoteBook</a></li><li class="chapter-item expanded affix "><li class="part-title">计算机体系结构</li><li class="chapter-item expanded "><a href="../01_体系结构/index.html"><strong aria-hidden="true">1.</strong> 体系结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/01_SMMU/index.html"><strong aria-hidden="true">1.1.</strong> 内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/01_SMMU/内存管理基础.html"><strong aria-hidden="true">1.1.1.</strong> 内存管理基础</a></li><li class="chapter-item expanded "><a href="../01_体系结构/01_SMMU/SMMU.html"><strong aria-hidden="true">1.1.2.</strong> SMMU</a></li><li class="chapter-item expanded "><a href="../01_体系结构/01_SMMU/SVA.html"><strong aria-hidden="true">1.1.3.</strong> 异构内存管理SVA</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/index.html"><strong aria-hidden="true">1.2.</strong> NoC片上互连</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/CHI.html"><strong aria-hidden="true">1.2.1.</strong> CHI协议</a></li><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/NoC_introduction.html"><strong aria-hidden="true">1.2.2.</strong> NoC</a></li><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/CMN700.html"><strong aria-hidden="true">1.2.3.</strong> CMN700</a></li><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/NI_700.html"><strong aria-hidden="true">1.2.4.</strong> NI-700</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/index.html"><strong aria-hidden="true">1.3.</strong> 异常与中断</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/中断.html"><strong aria-hidden="true">1.3.1.</strong> 异常与中断</a></li><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/GIC.html"><strong aria-hidden="true">1.3.2.</strong> ARM GIC</a></li><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/X86_APIC.html"><strong aria-hidden="true">1.3.3.</strong> X86 APIC</a></li><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/RISCV_AIA.html"><strong aria-hidden="true">1.3.4.</strong> RISCV AIA</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/05_CortexM3/index.html"><strong aria-hidden="true">1.4.</strong> SoC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/05_CortexM3/概述.html"><strong aria-hidden="true">1.4.1.</strong> Cortex M3 MCU</a></li><li class="chapter-item expanded "><a href="../12_PCIe/01_PCIe子系统简介/index.html"><strong aria-hidden="true">1.4.2.</strong> ARM N2 参考设计</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/index.html"><strong aria-hidden="true">1.5.</strong> 固件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/ARM固件启动顺序.html"><strong aria-hidden="true">1.5.1.</strong> ARM固件启动顺序</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/RISCV_firmware.html"><strong aria-hidden="true">1.5.2.</strong> RISC-V固件启动顺序</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/Cache_as_ram.html"><strong aria-hidden="true">1.5.3.</strong> Cache as RAM & On chip memory</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/EDK2_SYS_TABLE.html"><strong aria-hidden="true">1.5.4.</strong> EDK2 System Table</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/EDK2_EVENT.html"><strong aria-hidden="true">1.5.5.</strong> EDK2 Event</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/EDK2_memmap.html"><strong aria-hidden="true">1.5.6.</strong> EDK2 Memory Map</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/index.html"><strong aria-hidden="true">1.6.</strong> 存储</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/file_system.html"><strong aria-hidden="true">1.6.1.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/RAID.html"><strong aria-hidden="true">1.6.2.</strong> RAID</a></li><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/ssd.html"><strong aria-hidden="true">1.6.3.</strong> SSD</a></li><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/分布式存储.html"><strong aria-hidden="true">1.6.4.</strong> 分布式存储系统</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/08_虚拟化与分布式/index.html"><strong aria-hidden="true">1.7.</strong> 虚拟化与分布式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/08_虚拟化与分布式/hypervisor.html"><strong aria-hidden="true">1.7.1.</strong> Hypervisor</a></li><li class="chapter-item expanded "><a href="../01_体系结构/08_虚拟化与分布式/MIT6824.html"><strong aria-hidden="true">1.7.2.</strong> MIT6824</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/09_Memory_Consistency/index.html"><strong aria-hidden="true">1.8.</strong> Memory consistency and cache coherence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/09_Memory_Consistency/memory_consistency.html"><strong aria-hidden="true">1.8.1.</strong> Memory consistency</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../02_固件/index.html"><strong aria-hidden="true">2.</strong> 固件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02_固件/ARM固件启动顺序.html"><strong aria-hidden="true">2.1.</strong> ARM固件启动顺序</a></li><li class="chapter-item expanded "><a href="../02_固件/RISCV_firmware.html"><strong aria-hidden="true">2.2.</strong> RISC-V固件启动顺序</a></li><li class="chapter-item expanded "><a href="../02_固件/Cache_as_ram.html"><strong aria-hidden="true">2.3.</strong> Cache as RAM & On chip memory</a></li><li class="chapter-item expanded "><a href="../02_固件/EDK2_SYS_TABLE.html"><strong aria-hidden="true">2.4.</strong> EDK2 System Table</a></li><li class="chapter-item expanded "><a href="../02_固件/EDK2_EVENT.html"><strong aria-hidden="true">2.5.</strong> EDK2 Event</a></li><li class="chapter-item expanded "><a href="../02_固件/EDK2_memmap.html"><strong aria-hidden="true">2.6.</strong> EDK2 Memory Map</a></li></ol></li><li class="chapter-item expanded "><a href="../03_OS/index.html"><strong aria-hidden="true">3.</strong> OS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03_OS/FreeRTOS.html"><strong aria-hidden="true">3.1.</strong> FreeRTOS</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">计算机工业标准</li><li class="chapter-item expanded "><a href="../10_ACPI/index.html"><strong aria-hidden="true">4.</strong> ACPI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10_ACPI/ACPI_overview.html"><strong aria-hidden="true">4.1.</strong> ACPI Overview</a></li><li class="chapter-item expanded "><a href="../10_ACPI/CEDT.html"><strong aria-hidden="true">4.2.</strong> CEDT</a></li></ol></li><li class="chapter-item expanded "><a href="../11_AMBA/index.html"><strong aria-hidden="true">5.</strong> AMBA</a></li><li class="chapter-item expanded "><a href="../12_PCIe/index.html"><strong aria-hidden="true">6.</strong> PCIe</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../12_PCIe/index.html"><strong aria-hidden="true">6.1.</strong> 协议学习</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/physical_layer.html"><strong aria-hidden="true">6.1.1.</strong> Physical Layer</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/data_link_layer.html"><strong aria-hidden="true">6.1.2.</strong> Data Link Layer</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/TransactionLayer.html"><strong aria-hidden="true">6.1.3.</strong> Transaction Layer</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/03_pcie_eq.html"><strong aria-hidden="true">6.1.4.</strong> PCIe 均衡技术</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/02_1_tlp_flow_control.html"><strong aria-hidden="true">6.1.5.</strong> PCIe 流量控制</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/02_3_Transaction_Ordering.html"><strong aria-hidden="true">6.1.6.</strong> PCIe 传输顺序</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/04_pcie_aer.html"><strong aria-hidden="true">6.1.7.</strong> PCIe 错误处理</a></li></ol></li><li class="chapter-item expanded "><a href="../12_PCIe/01_PCIe子系统简介/index.html"><strong aria-hidden="true">6.2.</strong> ARM N2 参考设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../12_PCIe/01_PCIe子系统简介/01_PCIe子系统.html"><strong aria-hidden="true">6.2.1.</strong> 01_PCIe子系统.md</a></li></ol></li><li class="chapter-item expanded "><a href="../12_PCIe/02_PCIe枚举与资源分配/index.html"><strong aria-hidden="true">6.3.</strong> PCIe 枚举与资源分配</a></li><li class="chapter-item expanded "><a href="../12_PCIe/02_PCIe枚举与资源分配/枚举过程中的资源降级.html"><strong aria-hidden="true">6.4.</strong> 枚举过程中的资源降级</a></li><li class="chapter-item expanded "><a href="../12_PCIe/02_PCIe枚举与资源分配/EDK2对optionRom的支持.html"><strong aria-hidden="true">6.5.</strong> EDK2对optionRom的支持</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/index.html"><strong aria-hidden="true">6.6.</strong> PCIe 高级特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_AER.html"><strong aria-hidden="true">6.6.1.</strong> PCIe AER</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_Interrupt.html"><strong aria-hidden="true">6.6.2.</strong> PCIe Interrupt</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_Hot_Plug.html"><strong aria-hidden="true">6.6.3.</strong> PCIe Hot-Plug</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_Power_management.html"><strong aria-hidden="true">6.6.4.</strong> PCIe Power Management</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_DPC.html"><strong aria-hidden="true">6.6.5.</strong> PCIe_DPC.md</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../13_CXL/index.html"><strong aria-hidden="true">7.</strong> CXL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../13_CXL/01_cxl.html"><strong aria-hidden="true">7.1.</strong> CXL Overview</a></li><li class="chapter-item expanded "><a href="../13_CXL/cxl_reg.html"><strong aria-hidden="true">7.2.</strong> CXL 寄存器</a></li><li class="chapter-item expanded "><a href="../13_CXL/CXL_in_CMN.html"><strong aria-hidden="true">7.3.</strong> CXL_in_CMN</a></li><li class="chapter-item expanded "><a href="../13_CXL/CXL_in_SCP.html"><strong aria-hidden="true">7.4.</strong> CXL_in_SCP</a></li><li class="chapter-item expanded "><a href="../13_CXL/cxl枚举.html"><strong aria-hidden="true">7.5.</strong> CXL 枚举</a></li></ol></li><li class="chapter-item expanded "><a href="../14_DDR/index.html"><strong aria-hidden="true">8.</strong> DDR</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../14_DDR/01_Introduction.html"><strong aria-hidden="true">8.1.</strong> DDR Introduction</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">代码实现与工具</li><li class="chapter-item expanded "><a href="../21_LeetCode/LeetCode.html"><strong aria-hidden="true">9.</strong> LeetCode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../21_LeetCode/c_basic.html"><strong aria-hidden="true">9.1.</strong> C语言基础</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/08_array.html" class="active"><strong aria-hidden="true">9.2.</strong> 数组</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/09_matric.html"><strong aria-hidden="true">9.3.</strong> 矩阵</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/03_字符串.html"><strong aria-hidden="true">9.4.</strong> 字符串</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/02_链表.html"><strong aria-hidden="true">9.5.</strong> 链表</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/10_二叉树.html"><strong aria-hidden="true">9.6.</strong> 二叉树</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/13_heap.html"><strong aria-hidden="true">9.7.</strong> 堆</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/07_stack.html"><strong aria-hidden="true">9.8.</strong> 栈</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/04_bitmap.html"><strong aria-hidden="true">9.9.</strong> Bit Map</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/05_hashmap.html"><strong aria-hidden="true">9.10.</strong> 哈希表</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/00_排序.html"><strong aria-hidden="true">9.11.</strong> 排序</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/01_二分法.html"><strong aria-hidden="true">9.12.</strong> 二分法</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/06_double_ptr.html"><strong aria-hidden="true">9.13.</strong> 双指针</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/12_回溯.html"><strong aria-hidden="true">9.14.</strong> 回溯</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/11_动态规划.html"><strong aria-hidden="true">9.15.</strong> 动态规划</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/14_贪心.html"><strong aria-hidden="true">9.16.</strong> 贪心</a></li></ol></li><li class="chapter-item expanded "><a href="../22_System_design/index.html"><strong aria-hidden="true">10.</strong> System Design</a></li><li class="chapter-item expanded "><a href="../22_System_design/System_Design_Overview.html"><strong aria-hidden="true">11.</strong> System Design Overview</a></li><li class="chapter-item expanded "><a href="../20_tool/index.html"><strong aria-hidden="true">12.</strong> Tool</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../20_tool/git.html"><strong aria-hidden="true">12.1.</strong> Git</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">读书</li><li class="chapter-item expanded "><a href="../30_reading/工作中的好习惯.html"><strong aria-hidden="true">13.</strong> 工作中的好习惯</a></li><li class="chapter-item expanded "><a href="../30_reading/2024_reading.html"><strong aria-hidden="true">14.</strong> 2024 Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NoteBook</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>[toc]</p>
<h2 id="53-最大子数组和"><a class="header" href="#53-最大子数组和"><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></a></h2>
<pre><code>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
</code></pre>
<p>动态规划</p>
<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int maxSum = nums[0];  // 初始最大和为第一个元素
        int currentSum = nums[0];  // 当前子数组的和为第一个元素

        for (int i = 1; i &lt; nums.size(); ++i) {
            // 如果当前子数组的和加上当前元素比当前元素本身还小，就从当前元素重新开始
            currentSum = max(nums[i], currentSum + nums[i]);
            // 更新最大和
            maxSum = max(maxSum, currentSum);
        }

        return maxSum;
    }
};

</code></pre>
<p>遍历数组：</p>
<ul>
<li>
<p>从数组的第二个元素开始遍历（因为第一个元素已经在初始化时处理了）。</p>
</li>
<li>
<p>对于每个元素nums[i]，有两种选择：</p>
<ul>
<li>将其加入当前子数组中（即 <code>currentSum + nums[i]</code>）；</li>
<li>或者以当前元素作为新的子数组的起点（即 <code>nums[i]</code> 自身）。</li>
</ul>
</li>
<li>
<p>更新 <code>currentSum</code> 为以上两种选择中的较大值，这保证 <code>currentSum</code> 始终为以当前元素结尾的子数组的最大和。</p>
</li>
<li>
<p>同时更新 <code>maxSum</code>，记录全局的最大和。</p>
</li>
</ul>
<h2 id="56-合并区间"><a class="header" href="#56-合并区间"><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></a></h2>
<pre><code>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
</code></pre>
<p>排序+双指针</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        sort(intervals.begin(), intervals.end());

        vector&lt;vector&lt;int&gt;&gt; ans;

        for (int i = 0; i&lt;intervals.size();) {
            int t = intervals[i][1];
            int j = i + 1;

            while (j &lt; intervals.size() &amp;&amp; intervals[j][0] &lt;= t) {
                t = max(t, intervals[j][1]);
                j++;
            }

            ans.push_back({intervals[i][0], t});
            i = j;
        }

        return ans;

    }
};
</code></pre>
<ul>
<li>
<p>对 vector&lt;vector<int>&gt; 排序，需要按照先比较区间开始，如果相同再比较区间结束，使用默认的排序规则即可</p>
</li>
<li>
<p>使用双指针，左边指针指向当前区间的开始</p>
</li>
<li>
<p>使用一个变量来记录连续的范围 t</p>
</li>
<li>
<p>右指针开始往后寻找，如果后续的区间的开始值比 t 还小，说明重复了，可以归并到一起</p>
</li>
<li>
<p>此时更新更大的结束值到 t</p>
</li>
<li>
<p>直到区间断开，将 t 作为区间结束，存储到答案里</p>
</li>
<li>
<p>然后移动左指针，跳过中间已经合并的区间</p>
</li>
</ul>
<p>链接：https://leetcode.cn/problems/merge-intervals/solutions/204318/merge-intervals-by-ikaruga/</p>
<h2 id="66-加一"><a class="header" href="#66-加一"><a href="https://leetcode.cn/problems/plus-one/">66. 加一</a></a></h2>
<pre><code>输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
</code></pre>
<p>在原来的数组基础上，直接加。</p>
<p>从后往前加，最后一位如果需要进位，就循环一次，如果不需要进位，加一次就结束。</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
        int len = digits.size();

        for (int index = len - 1; index &gt;= 0; index--) {
            digits[index] = (digits[index] + 1) % 10;
            if (digits[index] != 0) {
                return digits;
            }
        }

        // all are 9
        digits.insert(digits.begin(), 1);
        return digits;

    }
};
</code></pre>
<p>如果输入的数组 <code>digits</code> 是 <code>[1, 2, 9]</code>，按照上述代码的执行过程来解释：</p>
<ol>
<li>初始输入：<code>digits = [1, 2, 9]</code></li>
<li>获取数组长度：<code>len = 3</code></li>
<li>开始从最后一位向前遍历：
<ul>
<li>第一次循环（i = 2）：<code>digits[2] = (9 + 1) % 10 = 0</code></li>
<li>继续判断 <code>digits[2] != 0</code>，不满足条件，继续下一次循环。</li>
<li>第二次循环（i = 1）：<code>digits[1] = (2 + 1) % 10 = 3</code></li>
<li>返回 <code>[1, 3, 0]</code>，因为此时 <code>digits[1] != 0</code>。</li>
</ul>
</li>
</ol>
<p>所以，对于输入 <code>digits = [1, 2, 9]</code>，经过加一操作后，结果会是 <code>[1, 3, 0]</code>。</p>
<p>如果输入的数组 <code>digits</code> 是 <code>[1, 2, 3]</code>，按照上述代码的执行过程来解释：</p>
<ol>
<li>初始输入：<code>digits = [1, 2, 3]</code></li>
<li>获取数组长度：<code>len = 3</code></li>
<li>开始从最后一位向前遍历：
<ul>
<li>第一次循环（i = 2）：<code>digits[2] = (3 + 1) % 10 = 4</code></li>
<li>继续判断 <code>digits[2] != 0</code>，满足条件，直接返回 <code>[1, 2, 4]</code>。</li>
</ul>
</li>
</ol>
<p>因此，对于输入 <code>digits = [1, 2, 3]</code>，经过加一操作后，结果会是 <code>[1, 2, 4]</code>。</p>
<h2 id="88-合并两个有序数组"><a class="header" href="#88-合并两个有序数组"><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></a></h2>
<pre><code>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
</code></pre>
<p>使用三个指针，从后往前合并；分别指向两个数组有效数字的末尾，及空数组的末尾。</p>
<p>类似华容道。</p>
<pre><code class="language-c++">class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        int p1 = m - 1;
        int p2 = n - 1;
        int p3 = m + n - 1;

        while(p1&gt;=0&amp;&amp;p2&gt;=0){
            if(nums1[p1]&gt;=nums2[p2]){
                nums1[p3]=nums1[p1];
                p3--;
                p1--;
            }else{
                nums1[p3]=nums2[p2];
                p3--;
                p2--;
            }
        }
        // 如果 nums2 中的元素比 nums1 中的元素都小，
        // 或者 nums1 中的元素已经遍历完，剩余的 nums2 元素可以直接放入 nums1 的开头。
        while(p2&gt;=0){
                nums1[p3]=nums2[p2];
                p3--;
                p2--;
        }
    }
};
</code></pre>
<h2 id="239-滑动窗口最大值"><a class="header" href="#239-滑动窗口最大值"><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></a></h2>
<pre><code>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>
<p>直接便利，k中找最大，一共有<em>n-k+1</em>个窗口，复杂度是 <em>O</em>((<em>n</em>−<em>k</em>+1)<em>k</em>)=<em>O</em>(<em>nk</em>)，可能会超出时间限制。</p>
<p>类似于最小栈那个题，最快的速度获得最小值。</p>
<p>构建一个辅助队列，记录最大值的序号，超过范围，从前面弹出，不是最大，从后面都弹出，然后加入队列尾部。</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
        vector&lt;int&gt; result;  // 存储结果的向量，用于保存每个窗口的最大值
        deque&lt;int&gt; deq;      // 双端队列，用于存储窗口中元素的索引

        for (int i = 0; i &lt; nums.size(); ++i) {
            // 如果队列中的元素索引已经超出当前窗口的左边界，则移除它
            if (!deq.empty() &amp;&amp; deq.front() == i - k) {
                deq.pop_front();
            }

            // 移除队列中所有比当前元素小的元素，它们不再可能是最大值
            while (!deq.empty() &amp;&amp; nums[deq.back()] &lt; nums[i]) {
                deq.pop_back();
            }

            // 将当前元素的索引加入队列
            deq.push_back(i);

            // 当窗口的索引达到 k-1 时（即窗口大小为 k），开始记录最大值
            if (i &gt;= k - 1) {
                result.push_back(nums[deq.front()]);  // 队列头部的元素是当前窗口的最大值
            }
        }

        return result;  // 返回所有窗口的最大值
    }
};

</code></pre>
<h2 id="189-轮转数组"><a class="header" href="#189-轮转数组"><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></a></h2>
<pre><code>输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
</code></pre>
<p>需要记得取余数，如果不取余数，长度为2，k=5，就会出错。</p>
<pre><code class="language-c++">class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        k = k % nums.size();
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin() + k);
        reverse(nums.begin() + k, nums.end());
    }
};
</code></pre>
<h2 id="238-除自身以外数组的乘积"><a class="header" href="#238-除自身以外数组的乘积"><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></a></h2>
<p>我们可以通过构造两个数组来存储每个元素的<strong>前缀积</strong>和<strong>后缀积</strong>，进而得到所需的结果。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><strong>前缀积数组 <code>prefix</code></strong>：
<ul>
<li><code>prefix[i]</code> 存储的是 <code>nums[0]</code> 到 <code>nums[i-1]</code> 的乘积，即不包括当前元素 <code>nums[i]</code>。</li>
<li>我们可以从左到右遍历数组，逐步构建这个前缀积数组。</li>
</ul>
</li>
<li><strong>后缀积数组 <code>suffix</code></strong>：
<ul>
<li><code>suffix[i]</code> 存储的是 <code>nums[i+1]</code> 到 <code>nums[n-1]</code> 的乘积，同样不包括当前元素 <code>nums[i]</code>。</li>
<li>我们可以从右到左遍历数组，逐步构建这个后缀积数组。</li>
</ul>
</li>
<li><strong>结果数组 <code>answer</code></strong>：
<ul>
<li>对于每个位置 <code>i</code>，结果 <code>answer[i]</code> 等于 <code>prefix[i]</code> 和 <code>suffix[i]</code> 的乘积。即 <code>answer[i] = prefix[i] * suffix[i]</code>。</li>
</ul>
</li>
<li><strong>优化空间</strong>：
<ul>
<li>实际上，我们可以在不使用额外的 <code>prefix</code> 和 <code>suffix</code> 数组的情况下实现同样的功能，通过一个数组直接在遍历过程中计算结果。</li>
</ul>
</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        vector&lt;int&gt; answer(n, 1);  // 初始化结果数组为 1

        // 构建前缀积
        int prefix = 1;
        for (int i = 0; i &lt; n; ++i) {
            answer[i] = prefix;  // 当前 answer[i] 存储的是前缀积
            prefix *= nums[i];   // 更新 prefix 为下一个位置的前缀积
        }

        // 构建后缀积并直接更新到结果数组
        int suffix = 1;
        for (int i = n - 1; i &gt;= 0; --i) {
            answer[i] *= suffix; // 当前 answer[i] 与后缀积相乘
            suffix *= nums[i];   // 更新 suffix 为下一个位置的后缀积
        }

        return answer;
    }
};

</code></pre>
<h2 id="41-缺失的第一个正数"><a class="header" href="#41-缺失的第一个正数"><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></a></h2>
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
</code></pre>
<p>如果没那么多事，直接塞进哈希表，再从1开始枚举正整数。时间空间都是O(n)</p>
<pre><code class="language-c++">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; table;

        for (auto x:nums) {
            table.insert(x);
        }

        for (int i = 1; i&lt; INT_MAX; i++) {
            if (table.find(i) == table.end()) {
                return i;
            }
        }

        return 0;

    }
};
</code></pre>
<p>置换做法：</p>
<p>尽量将数组中的元素尽可能地放在它们正确的位置上。</p>
<p>数组中第一个不满足 <code>nums[i] == i+1</code> 的位置 <code>i</code>，就是我们要找的最小正整数。</p>
<p>判决条件：（即 <code>nums[i] != nums[nums[i] - 1]</code>）</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><strong>交换元素到正确位置</strong>：
<ul>
<li>我们遍历数组 <code>nums</code>，对于每个元素 <code>nums[i]</code>，如果它的值在 <code>[1, n]</code> 之间，并且它不在正确的位置上（即 <code>nums[i] != nums[nums[i] - 1]</code>），就将它与 <code>nums[nums[i] - 1]</code> 交换。这个过程会将每个数字尽可能地放在它应该在的位置上。</li>
</ul>
</li>
<li><strong>寻找第一个不满足条件的位置</strong>：
<ul>
<li>在完成交换后，再次遍历数组，找到第一个 <code>nums[i] != i + 1</code> 的位置 <code>i</code>，则 <code>i + 1</code> 就是第一个缺失的正整数。</li>
</ul>
</li>
<li><strong>返回结果</strong>：
<ul>
<li>如果所有位置都满足条件，说明数组包含了 <code>[1, n]</code> 之间的所有整数，则返回 <code>n + 1</code>。</li>
</ul>
</li>
</ol>
<pre><code class="language-c++">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        
        // 将每个数字放到它应该在的位置上
        for (int i = 0; i &lt; n; ++i) {
            while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        
        // 找到第一个不满足 nums[i] == i + 1 的位置
        for (int i = 0; i &lt; n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        
        // 如果所有位置都满足条件，返回 n + 1
        return n + 1;
    }
};

</code></pre>
<p>输入数组为 <code>nums = [7, 8, 9, 11, 12]</code>。</p>
<p>经过第一步处理后，数组 <code>nums</code> 保持不变，仍然是 <code>[7, 8, 9, 11, 12]</code>。</p>
<p>我们再次遍历数组，寻找第一个不满足 <code>nums[i] == i + 1</code> 的位置 <code>i</code>。</p>
<p><code>nums[0] = 7</code>，不等于 <code>1</code>（即 <code>i + 1</code>），因此第一个缺失的正整数就是 <code>1</code>。</p>
<h2 id="31-下一个排列"><a class="header" href="#31-下一个排列"><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></a></h2>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。</p>
<p>以数字序列 [1,2,3] 为例，其排列按照字典序依次为：</p>
<p>[1,2,3]
[1,3,2]
[2,1,3]
[2,3,1]
[3,1,2]
[3,2,1]</p>
<p>这样，排列 [2,3,1] 的下一个排列即为 [3,1,2]。特别的，最大的排列 [3,2,1] 的下一个排列为最小的排列 [1,2,3]。</p>
<pre><code class="language-c++">class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        int i = nums.size() - 2;
        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) {
            i--;
        }
        if (i &gt;= 0) {
            int j = nums.size() - 1;
            while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) {
                j--;
            }
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
};

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../21_LeetCode/c_basic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../21_LeetCode/09_matric.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../21_LeetCode/c_basic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../21_LeetCode/09_matric.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
