<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>二叉树 - NoteBook</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">NoteBook</a></li><li class="chapter-item expanded affix "><li class="part-title">计算机体系结构</li><li class="chapter-item expanded "><a href="../01_体系结构/index.html"><strong aria-hidden="true">1.</strong> 体系结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/01_SMMU/index.html"><strong aria-hidden="true">1.1.</strong> 内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/01_SMMU/内存管理基础.html"><strong aria-hidden="true">1.1.1.</strong> 内存管理基础</a></li><li class="chapter-item expanded "><a href="../01_体系结构/01_SMMU/SMMU.html"><strong aria-hidden="true">1.1.2.</strong> SMMU</a></li><li class="chapter-item expanded "><a href="../01_体系结构/01_SMMU/SVA.html"><strong aria-hidden="true">1.1.3.</strong> 异构内存管理SVA</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/index.html"><strong aria-hidden="true">1.2.</strong> NoC片上互连</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/CHI.html"><strong aria-hidden="true">1.2.1.</strong> CHI协议</a></li><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/NoC_introduction.html"><strong aria-hidden="true">1.2.2.</strong> NoC</a></li><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/CMN700.html"><strong aria-hidden="true">1.2.3.</strong> CMN700</a></li><li class="chapter-item expanded "><a href="../01_体系结构/04_NoC片内互连总线/NI_700.html"><strong aria-hidden="true">1.2.4.</strong> NI-700</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/index.html"><strong aria-hidden="true">1.3.</strong> 异常与中断</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/中断.html"><strong aria-hidden="true">1.3.1.</strong> 异常与中断</a></li><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/GIC.html"><strong aria-hidden="true">1.3.2.</strong> ARM GIC</a></li><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/X86_APIC.html"><strong aria-hidden="true">1.3.3.</strong> X86 APIC</a></li><li class="chapter-item expanded "><a href="../01_体系结构/02_中断控制器/RISCV_AIA.html"><strong aria-hidden="true">1.3.4.</strong> RISCV AIA</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/05_CortexM3/index.html"><strong aria-hidden="true">1.4.</strong> SoC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/05_CortexM3/概述.html"><strong aria-hidden="true">1.4.1.</strong> Cortex M3 MCU</a></li><li class="chapter-item expanded "><a href="../12_PCIe/01_PCIe子系统简介/index.html"><strong aria-hidden="true">1.4.2.</strong> ARM N2 参考设计</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/index.html"><strong aria-hidden="true">1.5.</strong> 固件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/ARM固件启动顺序.html"><strong aria-hidden="true">1.5.1.</strong> ARM固件启动顺序</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/RISCV_firmware.html"><strong aria-hidden="true">1.5.2.</strong> RISC-V固件启动顺序</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/Cache_as_ram.html"><strong aria-hidden="true">1.5.3.</strong> Cache as RAM & On chip memory</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/EDK2_SYS_TABLE.html"><strong aria-hidden="true">1.5.4.</strong> EDK2 System Table</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/EDK2_EVENT.html"><strong aria-hidden="true">1.5.5.</strong> EDK2 Event</a></li><li class="chapter-item expanded "><a href="../01_体系结构/06_固件/EDK2_memmap.html"><strong aria-hidden="true">1.5.6.</strong> EDK2 Memory Map</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/index.html"><strong aria-hidden="true">1.6.</strong> 存储</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/file_system.html"><strong aria-hidden="true">1.6.1.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/RAID.html"><strong aria-hidden="true">1.6.2.</strong> RAID</a></li><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/ssd.html"><strong aria-hidden="true">1.6.3.</strong> SSD</a></li><li class="chapter-item expanded "><a href="../01_体系结构/07_存储/分布式存储.html"><strong aria-hidden="true">1.6.4.</strong> 分布式存储系统</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/08_虚拟化与分布式/index.html"><strong aria-hidden="true">1.7.</strong> 虚拟化与分布式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/08_虚拟化与分布式/hypervisor.html"><strong aria-hidden="true">1.7.1.</strong> Hypervisor</a></li><li class="chapter-item expanded "><a href="../01_体系结构/08_虚拟化与分布式/MIT6824.html"><strong aria-hidden="true">1.7.2.</strong> MIT6824</a></li></ol></li><li class="chapter-item expanded "><a href="../01_体系结构/09_Memory_Consistency/index.html"><strong aria-hidden="true">1.8.</strong> Memory consistency and cache coherence</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_体系结构/09_Memory_Consistency/memory_consistency.html"><strong aria-hidden="true">1.8.1.</strong> Memory consistency</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../02_固件/index.html"><strong aria-hidden="true">2.</strong> 固件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02_固件/ARM固件启动顺序.html"><strong aria-hidden="true">2.1.</strong> ARM固件启动顺序</a></li><li class="chapter-item expanded "><a href="../02_固件/RISCV_firmware.html"><strong aria-hidden="true">2.2.</strong> RISC-V固件启动顺序</a></li><li class="chapter-item expanded "><a href="../02_固件/Cache_as_ram.html"><strong aria-hidden="true">2.3.</strong> Cache as RAM & On chip memory</a></li><li class="chapter-item expanded "><a href="../02_固件/EDK2_SYS_TABLE.html"><strong aria-hidden="true">2.4.</strong> EDK2 System Table</a></li><li class="chapter-item expanded "><a href="../02_固件/EDK2_EVENT.html"><strong aria-hidden="true">2.5.</strong> EDK2 Event</a></li><li class="chapter-item expanded "><a href="../02_固件/EDK2_memmap.html"><strong aria-hidden="true">2.6.</strong> EDK2 Memory Map</a></li></ol></li><li class="chapter-item expanded "><a href="../03_OS/index.html"><strong aria-hidden="true">3.</strong> OS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03_OS/FreeRTOS.html"><strong aria-hidden="true">3.1.</strong> FreeRTOS</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">计算机工业标准</li><li class="chapter-item expanded "><a href="../10_ACPI/index.html"><strong aria-hidden="true">4.</strong> ACPI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../10_ACPI/ACPI_overview.html"><strong aria-hidden="true">4.1.</strong> ACPI Overview</a></li><li class="chapter-item expanded "><a href="../10_ACPI/CEDT.html"><strong aria-hidden="true">4.2.</strong> CEDT</a></li></ol></li><li class="chapter-item expanded "><a href="../11_AMBA/index.html"><strong aria-hidden="true">5.</strong> AMBA</a></li><li class="chapter-item expanded "><a href="../12_PCIe/index.html"><strong aria-hidden="true">6.</strong> PCIe</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../12_PCIe/index.html"><strong aria-hidden="true">6.1.</strong> 协议学习</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/physical_layer.html"><strong aria-hidden="true">6.1.1.</strong> Physical Layer</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/data_link_layer.html"><strong aria-hidden="true">6.1.2.</strong> Data Link Layer</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/TransactionLayer.html"><strong aria-hidden="true">6.1.3.</strong> Transaction Layer</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/03_pcie_eq.html"><strong aria-hidden="true">6.1.4.</strong> PCIe 均衡技术</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/02_1_tlp_flow_control.html"><strong aria-hidden="true">6.1.5.</strong> PCIe 流量控制</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/02_3_Transaction_Ordering.html"><strong aria-hidden="true">6.1.6.</strong> PCIe 传输顺序</a></li><li class="chapter-item expanded "><a href="../12_PCIe/00_PCIe协议/04_pcie_aer.html"><strong aria-hidden="true">6.1.7.</strong> PCIe 错误处理</a></li></ol></li><li class="chapter-item expanded "><a href="../12_PCIe/01_PCIe子系统简介/index.html"><strong aria-hidden="true">6.2.</strong> ARM N2 参考设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../12_PCIe/01_PCIe子系统简介/01_PCIe子系统.html"><strong aria-hidden="true">6.2.1.</strong> 01_PCIe子系统.md</a></li></ol></li><li class="chapter-item expanded "><a href="../12_PCIe/02_PCIe枚举与资源分配/index.html"><strong aria-hidden="true">6.3.</strong> PCIe 枚举与资源分配</a></li><li class="chapter-item expanded "><a href="../12_PCIe/02_PCIe枚举与资源分配/枚举过程中的资源降级.html"><strong aria-hidden="true">6.4.</strong> 枚举过程中的资源降级</a></li><li class="chapter-item expanded "><a href="../12_PCIe/02_PCIe枚举与资源分配/EDK2对optionRom的支持.html"><strong aria-hidden="true">6.5.</strong> EDK2对optionRom的支持</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/index.html"><strong aria-hidden="true">6.6.</strong> PCIe 高级特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_AER.html"><strong aria-hidden="true">6.6.1.</strong> PCIe AER</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_Interrupt.html"><strong aria-hidden="true">6.6.2.</strong> PCIe Interrupt</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_Hot_Plug.html"><strong aria-hidden="true">6.6.3.</strong> PCIe Hot-Plug</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_Power_management.html"><strong aria-hidden="true">6.6.4.</strong> PCIe Power Management</a></li><li class="chapter-item expanded "><a href="../12_PCIe/03_PCIe高级特性/PCIe_DPC.html"><strong aria-hidden="true">6.6.5.</strong> PCIe_DPC.md</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../13_CXL/index.html"><strong aria-hidden="true">7.</strong> CXL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../13_CXL/01_cxl.html"><strong aria-hidden="true">7.1.</strong> CXL Overview</a></li><li class="chapter-item expanded "><a href="../13_CXL/02_cxl_type3.html"><strong aria-hidden="true">7.2.</strong> CXL SSD-通过CXL扩展内存</a></li><li class="chapter-item expanded "><a href="../13_CXL/cxl_reg.html"><strong aria-hidden="true">7.3.</strong> CXL 寄存器</a></li><li class="chapter-item expanded "><a href="../13_CXL/CXL_in_CMN.html"><strong aria-hidden="true">7.4.</strong> CXL_in_CMN</a></li><li class="chapter-item expanded "><a href="../13_CXL/CXL_in_SCP.html"><strong aria-hidden="true">7.5.</strong> CXL_in_SCP</a></li></ol></li><li class="chapter-item expanded "><a href="../13_CXL/cxl枚举.html"><strong aria-hidden="true">8.</strong> CXL 枚举</a></li><li class="chapter-item expanded "><a href="../14_DDR/index.html"><strong aria-hidden="true">9.</strong> DDR</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../14_DDR/01_Introduction.html"><strong aria-hidden="true">9.1.</strong> DDR Introduction</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">代码实现与工具</li><li class="chapter-item expanded "><a href="../21_LeetCode/LeetCode.html"><strong aria-hidden="true">10.</strong> LeetCode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../21_LeetCode/c_basic.html"><strong aria-hidden="true">10.1.</strong> C语言基础</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/08_array.html"><strong aria-hidden="true">10.2.</strong> 数组</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/09_matric.html"><strong aria-hidden="true">10.3.</strong> 矩阵</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/03_字符串.html"><strong aria-hidden="true">10.4.</strong> 字符串</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/02_链表.html"><strong aria-hidden="true">10.5.</strong> 链表</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/10_二叉树.html" class="active"><strong aria-hidden="true">10.6.</strong> 二叉树</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/13_heap.html"><strong aria-hidden="true">10.7.</strong> 堆</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/07_stack.html"><strong aria-hidden="true">10.8.</strong> 栈</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/04_bitmap.html"><strong aria-hidden="true">10.9.</strong> Bit Map</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/05_hashmap.html"><strong aria-hidden="true">10.10.</strong> 哈希表</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/00_排序.html"><strong aria-hidden="true">10.11.</strong> 排序</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/01_二分法.html"><strong aria-hidden="true">10.12.</strong> 二分法</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/06_double_ptr.html"><strong aria-hidden="true">10.13.</strong> 双指针</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/12_回溯.html"><strong aria-hidden="true">10.14.</strong> 回溯</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/11_动态规划.html"><strong aria-hidden="true">10.15.</strong> 动态规划</a></li><li class="chapter-item expanded "><a href="../21_LeetCode/14_贪心.html"><strong aria-hidden="true">10.16.</strong> 贪心</a></li></ol></li><li class="chapter-item expanded "><a href="../22_System_design/index.html"><strong aria-hidden="true">11.</strong> System Design</a></li><li class="chapter-item expanded "><a href="../22_System_design/System_Design_Overview.html"><strong aria-hidden="true">12.</strong> System Design Overview</a></li><li class="chapter-item expanded "><a href="../20_tool/index.html"><strong aria-hidden="true">13.</strong> Tool</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../20_tool/git.html"><strong aria-hidden="true">13.1.</strong> Git</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">读书</li><li class="chapter-item expanded "><a href="../30_reading/工作中的好习惯.html"><strong aria-hidden="true">14.</strong> 工作中的好习惯</a></li><li class="chapter-item expanded "><a href="../30_reading/2024_reading.html"><strong aria-hidden="true">15.</strong> 2024 Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NoteBook</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="二叉树"><a class="header" href="#二叉树">二叉树</a></h1>
<p>[toc]</p>
<p>三序遍历都用了栈，入栈顺序为根左右，因此前序遍历是从入栈就开始提取结果，中序遍历是根左入栈以后，开始出站时候提取结果。</p>
<h2 id="144-二叉树的前序遍历"><a class="header" href="#144-二叉树的前序遍历"><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></a></h2>
<p>先访问根节点，然后递归地访问左子树和右子树。</p>
<p>对于二叉树 <code>[1, 2, 3, 4, 5, 6, 7]</code> 的前序遍历顺序是：<code>[1, 2, 4, 5, 3, 6, 7]</code>。</p>
<pre><code class="language-c++">class Solution {
public:
    // 前序遍历：根节点 -&gt; 左子树 -&gt; 右子树
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; s;
        TreeNode* curr = root;
        
        // 两种情况需要继续，一是当前指针不为空，二是栈里还有元素
        while (curr != nullptr || !s.empty()) {
            // 不为空就要压栈，存储结果
            while (curr != nullptr) {
                result.push_back(curr-&gt;val); // 先访问根节点
                s.push(curr);
                curr = curr-&gt;left; // 递归访问左子树
            }
            // 为空的话就要弹栈，切换到右边
            curr = s.top();
            s.pop();
            curr = curr-&gt;right; // 访问右子树
        }
        
        return result;
    }
};
</code></pre>
<h2 id="94-二叉树的中序遍历"><a class="header" href="#94-二叉树的中序遍历"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></a></h2>
<p>先递归地访问左子树，然后访问根节点，最后访问右子树。</p>
<p>对于二叉树 <code>[1, 2, 3, 4, 5, 6, 7]</code> 的中序遍历顺序是：<code>[4, 2, 5, 1, 6, 3, 7]</code>。</p>
<pre><code class="language-c++">// 中序遍历：左子树 -&gt; 根节点 -&gt; 右子树
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; s;
        TreeNode* curr = root;
        
        while (curr != nullptr || !s.empty()) {
            while (curr != nullptr) {
                s.push(curr);
                curr = curr-&gt;left; // 递归访问左子树
            }
            curr = s.top();
            s.pop();
            result.push_back(curr-&gt;val); // 访问根节点
            curr = curr-&gt;right; // 访问右子树
        }
        
        return result;
    }
</code></pre>
<p>二叉搜索树具有一个重要性质：<strong>二叉搜索树的中序遍历为递增序列</strong>。</p>
<h2 id="145-二叉树的后序遍历"><a class="header" href="#145-二叉树的后序遍历"><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></a></h2>
<p>先递归地访问左子树，然后递归地访问右子树，最后访问根节点。</p>
<p>与中序的不同之处在于：</p>
<ul>
<li>中序遍历中，从栈中弹出的节点，其左子树是访问完了，可以直接访问该节点，然后接下来访问右子树。</li>
<li>后序遍历中，从栈中弹出的节点，我们只能确定其左子树肯定访问完了，但是无法确定右子树是否访问过。</li>
</ul>
<p>因此，我们在后序遍历中，引入了一个prev来记录历史访问记录。</p>
<pre><code class="language-c++">// 后序遍历：左子树 -&gt; 右子树 -&gt; 根节点
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; s;
        TreeNode* curr = root;
        // 上一个访问过的节点指针，用于判断右子树是否访问完毕
        TreeNode* prev = nullptr;
        
        while (curr != nullptr || !s.empty()) {
            while (curr != nullptr) {
                s.push(curr);
                curr = curr-&gt;left; // 递归访问左子树
            }
            
            curr = s.top();
            
            // 检查右子树为空或已访问过
            //现在需要确定的是是否有右子树，或者右子树是否访问过
            //如果没有右子树，或者右子树访问完了，也就是上一个访问的节点是右子节点时
            //说明可以访问当前节点
            // 到底了，如果右子树为空，将左子树记录到ans中，将左子树从栈中弹出
            if (curr-&gt;right == nullptr || curr-&gt;right == prev) {
                result.push_back(curr-&gt;val); // 访问根节点
                s.pop(); // 弹出根节点
                prev = curr; 
                 // 当前节点置空，保证下一次循环不会立即再次处理根节点
                curr = nullptr;
            } else {
                curr = curr-&gt;right; // 访问右子树
            }
        }
        
        return result;
    }
</code></pre>
<p>假设这棵二叉树的结构是：</p>
<pre><code>    1
   / \
  2   3
 / \ / \
4  5 6  7
</code></pre>
<p><strong>初始状态：</strong></p>
<ul>
<li><code>result</code>: 空向量</li>
<li><code>s</code>: 空栈</li>
<li><code>curr</code>: 指向根节点 <code>1</code></li>
<li><code>prev</code>: <code>nullptr</code></li>
</ul>
<p><strong>第一步：</strong></p>
<ol>
<li>将 <code>1</code> 入栈，访问左子树：
<ul>
<li>栈 <code>s</code>: [1]</li>
<li><code>curr</code>: 指向 <code>2</code></li>
</ul>
</li>
<li>将 <code>2</code> 入栈，访问左子树：
<ul>
<li>栈 <code>s</code>: [1, 2]</li>
<li><code>curr</code>: 指向 <code>4</code></li>
</ul>
</li>
<li><code>4</code> 的左子树为空，将 <code>4</code> 入栈后，访问左子树结束：
<ul>
<li>栈 <code>s</code>: [1, 2, 4]</li>
<li><code>curr</code>: <code>nullptr</code></li>
</ul>
</li>
</ol>
<p><strong>第二步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>4</code>，检查右子树为空或已访问过，可以访问 <code>4</code>：</p>
<ul>
<li>将 <code>4</code> 加入 <code>result</code></li>
<li>弹出 <code>4</code>，更新 <code>prev = 4</code></li>
<li><code>curr</code> 置空，以防止立即处理该节点</li>
</ul>
<p>现在，栈 <code>s</code> 变为 [1, 2]，<code>curr</code> 指向 <code>2</code></p>
</li>
</ol>
<p><strong>第三步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>2</code>，尝试访问右子树 <code>5</code>：</p>
<ul>
<li>
<p>将5入栈，访问左子树：</p>
<ul>
<li>栈 <code>s</code>: [1, 2, 5]</li>
<li><code>curr</code>: 指向 <code>nullptr</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>5</code> 的左子树为空，将 <code>5</code> 入栈后，访问左子树结束：</p>
<ul>
<li>栈 <code>s</code>: [1, 2, 5]</li>
<li><code>curr</code>: <code>nullptr</code></li>
</ul>
</li>
</ol>
<p><strong>第四步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>5</code>，检查右子树为空或已访问过，可以访问 <code>5</code>：</p>
<ul>
<li>将 <code>5</code> 加入 <code>result</code></li>
<li>弹出 <code>5</code>，更新 <code>prev = 5</code></li>
<li><code>curr</code> 置空</li>
</ul>
<p>现在，栈 <code>s</code> 变为 [1, 2]，<code>curr</code> 指向 <code>2</code></p>
</li>
</ol>
<p><strong>第五步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>2</code>，尝试访问右子树 <code>3</code>：</p>
<ul>
<li>
<p>将3入栈，访问左子树：</p>
<ul>
<li>栈 <code>s</code>: [1, 2, 3]</li>
<li><code>curr</code>: 指向 <code>6</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>6</code> 的左子树为空，将 <code>6</code> 入栈后，访问左子树结束：</p>
<ul>
<li>栈 <code>s</code>: [1, 2, 3, 6]</li>
<li><code>curr</code>: <code>nullptr</code></li>
</ul>
</li>
</ol>
<p><strong>第六步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>6</code>，尝试访问右子树 <code>7</code>：</p>
<ul>
<li>
<p>将7入栈，访问左子树：</p>
<ul>
<li>栈 <code>s</code>: [1, 2, 3, 6, 7]</li>
<li><code>curr</code>: 指向 <code>nullptr</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>7</code> 的左子树为空，将 <code>7</code> 入栈后，访问左子树结束：</p>
<ul>
<li>栈 <code>s</code>: [1, 2, 3, 6, 7]</li>
<li><code>curr</code>: <code>nullptr</code></li>
</ul>
</li>
</ol>
<p><strong>第七步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>7</code>，检查右子树为空或已访问过，可以访问 <code>7</code>：</p>
<ul>
<li>将 <code>7</code> 加入 <code>result</code></li>
<li>弹出 <code>7</code>，更新 <code>prev = 7</code></li>
<li><code>curr</code> 置空</li>
</ul>
<p>现在，栈 <code>s</code> 变为 [1, 2, 3, 6]，<code>curr</code> 指向 <code>6</code></p>
</li>
</ol>
<p><strong>第八步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>6</code>，检查右子树为空或已访问过，可以访问 <code>6</code>：</p>
<ul>
<li>将 <code>6</code> 加入 <code>result</code></li>
<li>弹出 <code>6</code>，更新 <code>prev = 6</code></li>
<li><code>curr</code> 置空</li>
</ul>
<p>现在，栈 <code>s</code> 变为 [1, 2, 3]，<code>curr</code> 指向 <code>3</code></p>
</li>
</ol>
<p><strong>第九步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>3</code>，尝试访问右子树 <code>3</code>：</p>
<ul>
<li>
<p>将3入栈，访问左子树：</p>
<ul>
<li>栈 <code>s</code>: [1, 2, 3]</li>
<li><code>curr</code>: 指向 <code>nullptr</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>3</code> 的左子树为空，将 <code>3</code> 入栈后，访问左子树结束：</p>
<ul>
<li>栈 <code>s</code>: [1, 2, 3]</li>
<li><code>curr</code>: <code>nullptr</code></li>
</ul>
</li>
</ol>
<p><strong>第十步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>3</code>，尝试访问右子树 <code>nullptr</code>：</p>
<ul>
<li>
<p>3的右子树已访问过（<code>prev = 3</code>），可以访问3：</p>
<ul>
<li>将 <code>3</code> 加入 <code>result</code></li>
<li>弹出 <code>3</code>，更新 <code>prev = 3</code></li>
<li><code>curr</code> 置空</li>
</ul>
</li>
</ul>
<p>现在，栈 <code>s</code> 变为 [1, 2]，<code>curr</code> 指向 <code>2</code></p>
</li>
</ol>
<p><strong>第十一步：</strong></p>
<ol>
<li>
<p>栈顶为 <code>2</code>，尝试访问右子树 <code>2</code>：</p>
<ul>
<li>
<p>2的右子树已访问过（prev = 2），可以访问2：</p>
<ul>
<li>将 <code>2</code> 加入 <code>result</code></li>
<li>弹出 <code>2</code>，更新 <code>prev = 2</code></li>
<li><code>curr</code> 置空</li>
</ul>
</li>
</ul>
<p>现在，栈 <code>s</code> 变为 [1]，<code>curr</code> 指向 <code>1</code></p>
</li>
</ol>
<p><strong>第十二步：</strong></p>
<ol>
<li>
<p>栈顶为<code>1</code> ，尝试访问右子树<code>1</code> ：</p>
<ul>
<li>
<p>1的右子树已访问过（prev = 1 ），可以访问1：</p>
<ul>
<li>将 <code>1</code> 加入 <code>result</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>弹出 <code>1</code>，更新 <code>prev = 1</code>
<ul>
<li><code>curr</code> 置空</li>
</ul>
</li>
</ul>
<p><strong>最终结果：</strong></p>
<p>根据后序遍历的顺序，最终 <code>result</code> 的内容为 <code>[4, 5, 2, 6, 7, 3, 1]</code>。</p>
<h2 id="102-二叉树的层序遍历"><a class="header" href="#102-二叉树的层序遍历"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></a></h2>
<p>使用队列辅助，不断入队，出队，直到队列为空。</p>
<pre><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
    vector&lt;vector&lt;int&gt;&gt; result; // 存储层序遍历的结果
    if (root == nullptr) {
        return result; // 如果根节点为空，直接返回空结果
    }
    
    queue&lt;TreeNode*&gt; q; // 辅助队列用于层序遍历
    q.push(root); // 将根节点入队
    
    while (!q.empty()) { // 循环直到队列为空
        int currentLevelSize = q.size(); // 当前层的节点数
        vector&lt;int&gt; currentLevel; // 存储当前层节点值
        
        for (int i = 0; i &lt; currentLevelSize; ++i) {
            TreeNode* node = q.front(); // 取出队首节点
            q.pop(); // 出队
            
            currentLevel.push_back(node-&gt;val); // 将节点值加入当前层的向量
            
            if (node-&gt;left != nullptr) {
                q.push(node-&gt;left); // 左子节点入队
            }
            
            if (node-&gt;right != nullptr) {
                q.push(node-&gt;right); // 右子节点入队
            }
        }
        
        result.push_back(currentLevel); // 将当前层的向量加入结果中
    }
    
    return result; // 返回层序遍历的结果
}

</code></pre>
<h2 id="100-相同的树"><a class="header" href="#100-相同的树"><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></a></h2>
<pre><code class="language-c++">bool isSameTree(TreeNode* p, TreeNode* q) {
        // If both trees are empty, they are identical
        if (p == nullptr &amp;&amp; q == nullptr)
            return true;
        
        // If one of the trees is empty and the other is not, they are not identical
        if (p == nullptr || q == nullptr)
            return false;
        
        // Check if current nodes have the same value
        if (p-&gt;val != q-&gt;val)
            return false;
        
        // Recursively check left and right subtrees
        return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
    }
</code></pre>
<h2 id="101-对称二叉树"><a class="header" href="#101-对称二叉树"><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></a></h2>
<pre><code class="language-c++">bool isSymmetric(TreeNode* root) {
        if (root == nullptr)
            return true;
        
        return isMirror(root-&gt;left, root-&gt;right);
    }
    
private:
    bool isMirror(TreeNode* leftSubtree, TreeNode* rightSubtree) {
        // If both are nullptr, they are symmetric
        if (leftSubtree == nullptr &amp;&amp; rightSubtree == nullptr)
            return true;
        
        // If one of them is nullptr and the other is not, they are not symmetric
        if (leftSubtree == nullptr || rightSubtree == nullptr)
            return false;
        
        // Check if current nodes have the same value
        if (leftSubtree-&gt;val != rightSubtree-&gt;val)
            return false;
        
        // Recursively check inner structure
        return isMirror(leftSubtree-&gt;left, rightSubtree-&gt;right) &amp;&amp; 
               isMirror(leftSubtree-&gt;right, rightSubtree-&gt;left);
    }
</code></pre>
<h2 id="104-二叉树的最大深度"><a class="header" href="#104-二叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></a></h2>
<pre><code class="language-c++">int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;

        int leftDepth = maxDepth(root-&gt;left);
        int rightDepth = maxDepth(root-&gt;right);

        return 1 + std::max(leftDepth, rightDepth);

    }
</code></pre>
<h2 id="108-将有序数组转换为二叉搜索树"><a class="header" href="#108-将有序数组转换为二叉搜索树"><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></a></h2>
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p>
<p><strong>平衡二叉树</strong> 是指该树所有节点的左右子树的深度相差不超过 1。</p>
<p>二分搜索树（英语：Binary Search Tree），也称为 二叉查找树 、二叉搜索树 、有序二叉树或排序二叉树。满足以下几个条件：</p>
<ul>
<li>若它的左子树不为空，左子树上所有节点的值都小于它的根节点。</li>
<li>若它的右子树不为空，右子树上所有的节点的值都大于它的根节点。</li>
</ul>
<p>拎起中间的数，作为根，然后左右区间分别递归。</p>
<pre><code class="language-c++">class Solution {
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        // 调用辅助函数，传入数组、起始索引和结束索引
        return helper(nums, 0, nums.size() - 1);
    }

    TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right) {
        // 边界条件，如果左边界大于右边界，则返回空指针
        if (left &gt; right) {
            return nullptr;
        }

        // 计算中间节点的索引
        int mid = (left + right) / 2;

        // 创建当前中间节点作为根节点
        TreeNode* root = new TreeNode(nums[mid]);

        // 递归构建左子树和右子树
        root-&gt;left = helper(nums, left, mid - 1);
        root-&gt;right = helper(nums, mid + 1, right);

        // 返回当前根节点
        return root;
    }
};
</code></pre>
<h2 id="98-验证二叉搜索树"><a class="header" href="#98-验证二叉搜索树"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></a></h2>
<p>构造一个辅助函数，然后递归。</p>
<p>root 值介于左右</p>
<pre><code class="language-c++">class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) return true;

        if (root-&gt;val &lt;= lower || root-&gt;val &gt;= upper) {
            return false;
        }

        return helper(root-&gt;left, lower, root-&gt;val) \
               &amp;&amp; helper(root-&gt;right, root-&gt;val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);

    }
};
</code></pre>
<h2 id="230-二叉搜索树中第k小的元素"><a class="header" href="#230-二叉搜索树中第k小的元素"><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></a></h2>
<p>二叉搜索树具有一个重要性质：<strong>二叉搜索树的中序遍历为递增序列</strong>。</p>
<p>因此就是中序遍历，然后提取vector中第k-1个元素。</p>
<pre><code class="language-c++">class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode*&gt; stk;

        TreeNode* curr = root;

        while(curr!=nullptr || !stk.empty()) {
            while (curr!=nullptr) {
                stk.push(curr);
                curr = curr-&gt;left;
            }

            curr = stk.top();
            stk.pop();

            result.push_back(curr-&gt;val);
            curr = curr-&gt;right;
        }

        return result[k - 1];

    }
};
</code></pre>
<h2 id="236-二叉树的最近公共祖先"><a class="header" href="#236-二叉树的最近公共祖先"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></a></h2>
<pre><code class="language-c++">class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 如果根节点为空，或者根节点是 p 或 q 中的一个，则直接返回根节点
        if (root == NULL || root == p || root == q) return root;

        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);

        // 如果 left 为空，则表示左子树中不存在 p 和 q 的 LCA，此时返回右子树的结果。
        if (left == NULL) return right;
        if (right == NULL) return left;

         // 如果左右子树各自找到了不同的节点 p 和 q，则当前节点 root 就是它们的 LCA
        return root;
        
    }
};
</code></pre>
<h2 id="199-二叉树的右视图"><a class="header" href="#199-二叉树的右视图"><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></a></h2>
<p>层序遍历，每行最后一个元素。</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        vector&lt;int&gt; ans;

        if (root == nullptr) return ans;

        queue&lt;TreeNode*&gt; q;
        q.push(root);

        while(!q.empty()) {
            int current_level_size = q.size();

            vector&lt;int&gt; current_level_value;

            for (int i = 0; i &lt; current_level_size; i++) {
                TreeNode* node = q.front();
                q.pop();

                current_level_value.push_back(node-&gt;val);

                if (node-&gt;left != nullptr) {
                    q.push(node-&gt;left);
                }

                if (node-&gt;right != nullptr) {
                    q.push(node-&gt;right);
                }
            }
            // 层序遍历这里是存储数组，右视图的话是存储最后一个元素。
            ans.push_back(current_level_value[current_level_size - 1]);
        }

        return ans;

    }
};
</code></pre>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a class="header" href="#105-从前序与中序遍历序列构造二叉树"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></a></h2>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        // 特殊情况处理：如果先序遍历或中序遍历为空，则返回空指针
        if (preorder.empty() || inorder.empty()) {
            return nullptr;
        }
        
        // 调用递归构建二叉树
        return buildTreeRecursive(preorder, 0, preorder.size() - 1,
                                  inorder, 0, inorder.size() - 1);
    }
    
    // 递归构建二叉树的辅助函数
    TreeNode* buildTreeRecursive(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd,
                                 vector&lt;int&gt;&amp; inorder, int inStart, int inEnd) {
        // 如果先序遍历的起始位置大于结束位置，则当前子树为空，返回空指针
        if (preStart &gt; preEnd) {
            return nullptr;
        }
        
        // 先序遍历的第一个节点是当前子树的根节点
        int rootValue = preorder[preStart];
        TreeNode* root = new TreeNode(rootValue);
        
        // 在中序遍历中找到根节点的位置
        int rootIndexInInorder = inStart;
        while (rootIndexInInorder &lt;= inEnd &amp;&amp; inorder[rootIndexInInorder] != rootValue) {
            rootIndexInInorder++;
        }
        
        // 计算左子树的长度
        int leftSubtreeLength = rootIndexInInorder - inStart;
        
        // 递归构建左子树和右子树
        root-&gt;left = buildTreeRecursive(preorder, preStart + 1, preStart + leftSubtreeLength,
                                        inorder, inStart, rootIndexInInorder - 1);
        root-&gt;right = buildTreeRecursive(preorder, preStart + leftSubtreeLength + 1, preEnd,
                                         inorder, rootIndexInInorder + 1, inEnd);
        
        // 返回当前根节点
        return root;
    }
};

</code></pre>
<h2 id="110-平衡二叉树"><a class="header" href="#110-平衡二叉树"><a href="https://leetcode.cn/problems/balanced-binary-tree">110. 平衡二叉树</a></a></h2>
<p><strong>平衡二叉树</strong> 是指该树所有节点的左右子树的深度相差不超过 1。</p>
<p>把所有的高度都算一遍。和最大最小深度都类似。</p>
<pre><code class="language-c++">class Solution {
public:
    int height(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        } else {
            return max(height(root-&gt;left), height(root-&gt;right)) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        if (root == nullptr) {
            return true;
        } else {
            return abs(height(root-&gt;left) - height(root-&gt;right)) &lt;= 1 \
                   &amp;&amp; isBalanced(root-&gt;left) \
                   &amp;&amp; isBalanced(root-&gt;right);
        }

    }
};
</code></pre>
<h2 id="111-二叉树的最小深度"><a class="header" href="#111-二叉树的最小深度"><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree">111. 二叉树的最小深度</a></a></h2>
<pre><code class="language-c++">int minDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }

        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) {
            return 1;
        }

        int min_depth = INT_MAX;

        if (root-&gt;left != nullptr) {
            min_depth = min(min_depth, minDepth(root-&gt;left));
        }
        if (root-&gt;right != nullptr) {
            min_depth = min(min_depth, minDepth(root-&gt;right));
        }

        return min_depth + 1;

    }
</code></pre>
<h2 id="112-路径总和"><a class="header" href="#112-路径总和"><a href="https://leetcode.cn/problems/path-sum">112. 路径总和</a></a></h2>
<p>判断是否有等于目标值的路径。</p>
<p>递归</p>
<pre><code class="language-c++">class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return false;
        }

        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) {
            return targetSum == root-&gt;val;
        }

        return hasPathSum(root-&gt;left, targetSum - root-&gt;val) \
               || hasPathSum(root-&gt;right, targetSum - root-&gt;val);

    }
};
</code></pre>
<h2 id="437-路径总和-iii"><a class="header" href="#437-路径总和-iii"><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></a></h2>
<pre><code class="language-c++">class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return 0;

        int ans = rootSum(root, targetSum);

        ans += pathSum(root-&gt;left, targetSum);
        ans += pathSum(root-&gt;right, targetSum);

        return ans;

    }

    int rootSum(TreeNode* root, long targetSum) {
        if (root == nullptr) return 0;

        int ans = 0;

        if (root-&gt;val == targetSum) {
            ans++;
        }

        ans += rootSum(root-&gt;left, targetSum - root-&gt;val);
        ans += rootSum(root-&gt;right, targetSum - root-&gt;val);

        return ans;
    }
};
</code></pre>
<h2 id="114-二叉树展开为链表"><a class="header" href="#114-二叉树展开为链表"><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list">114. 二叉树展开为链表</a></a></h2>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<p>先前序遍历，然后再修改二叉树节点信息。</p>
<pre><code class="language-c++">class Solution {
public:
    void flatten(TreeNode* root) {
        vector&lt;TreeNode*&gt; result;
        stack&lt;TreeNode*&gt; stk;
        TreeNode* curr = root;
        
        while (curr != nullptr || !stk.empty()) {
            while (curr != nullptr) {
                result.push_back(curr);
                stk.push(curr);
                curr = curr-&gt;left;
            }

            curr = stk.top();
            stk.pop();
            curr = curr-&gt;right;
        }

        int size = result.size();

        for (int i = 1; i &lt; size; i++) {
            auto prev = result[i - 1];
            auto curr = result[i];

            prev-&gt;left = nullptr;
            prev-&gt;right = curr;
        }
    }
};
</code></pre>
<h2 id="226-翻转二叉树"><a class="header" href="#226-翻转二叉树"><a href="https://leetcode.cn/problems/invert-binary-tree">226. 翻转二叉树</a></a></h2>
<p>递归，和最大最小深度等都类似。</p>
<pre><code class="language-c++">class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }

        TreeNode* left = invertTree(root-&gt;left);
        TreeNode* right = invertTree(root-&gt;right);

        root-&gt;left = right;
        root-&gt;right = left;

        return root;

    }
};
</code></pre>
<h2 id="543-二叉树的直径"><a class="header" href="#543-二叉树的直径"><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></a></h2>
<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>
<p>求最大深度，然后加一。</p>
<pre><code class="language-c++">class Solution {
public:
    int ans;
    int diameterOfBinaryTree(TreeNode* root) {
        ans = 1;
        depth(root);
        return ans - 1;
    }
    int depth(TreeNode* root) {
        if (root == nullptr) return 0;

        int L = depth(root-&gt;left);
        int R = depth(root-&gt;right);

        // 更新 ans 为 max(ans, L + R + 1)，表示以当前节点为根的直径长度。
        ans = max(ans, L+R+1);

        // 返回当前节点为根节点的子树的深度 max(L, R) + 1。
        return max(L, R) + 1;
    }
};
</code></pre>
<h2 id="617-合并二叉树"><a class="header" href="#617-合并二叉树"><a href="https://leetcode.cn/problems/merge-two-binary-trees">617. 合并二叉树</a></a></h2>
<p>还是递归，如果都有值，需要相加。</p>
<pre><code class="language-c++">class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (root1 == nullptr) return root2;
        if (root2 == nullptr) return root1;

        auto merged = new TreeNode(root1-&gt;val + root2-&gt;val);
        merged-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);
        merged-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);

        return merged;

    }
};
</code></pre>
<h2 id="124-二叉树中的最大路径和"><a class="header" href="#124-二叉树中的最大路径和"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></a></h2>
<pre><code class="language-c++">class Solution {
public:
    int maxSum = INT_MIN;

    int maxGain (TreeNode* node) {
        if (node == nullptr) return 0;

        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = max(maxGain(node-&gt;left), 0);
        int rightGain = max(maxGain(node-&gt;right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node-&gt;val + leftGain + rightGain;

        // 更新答案
        maxSum = max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node-&gt;val + max(leftGain, rightGain);
    }

    int maxPathSum(TreeNode* root) {
        maxGain(root);
        return maxSum;

    }
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../21_LeetCode/02_链表.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../21_LeetCode/13_heap.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../21_LeetCode/02_链表.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../21_LeetCode/13_heap.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
